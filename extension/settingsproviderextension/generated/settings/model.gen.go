// Package settings provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package settings

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ArgumentBooleanArgumentType.
const (
	ArgumentBooleanArgumentTypeArgumentBoolean ArgumentBooleanArgumentType = "ArgumentBoolean"
)

// Defines values for ArgumentComparatorWithoutEqualityArgumentType.
const (
	ArgumentComparatorWithoutEqualityArgumentTypeArgumentComparatorWithoutEquality ArgumentComparatorWithoutEqualityArgumentType = "ArgumentComparatorWithoutEquality"
)

// Defines values for ArgumentDoubleArgumentType.
const (
	ArgumentDoubleArgumentTypeArgumentDouble ArgumentDoubleArgumentType = "ArgumentDouble"
)

// Defines values for ArgumentFailingHealthStateArgumentType.
const (
	ArgumentFailingHealthStateArgumentTypeArgumentFailingHealthState ArgumentFailingHealthStateArgumentType = "ArgumentFailingHealthState"
)

// Defines values for ArgumentLongArgumentType.
const (
	ArgumentLongArgumentTypeArgumentLong ArgumentLongArgumentType = "ArgumentLong"
)

// Defines values for ArgumentPromQLMetricArgumentType.
const (
	ArgumentPromQLMetricArgumentTypeArgumentPromQLMetric ArgumentPromQLMetricArgumentType = "ArgumentPromQLMetric"
)

// Defines values for ArgumentStringArgumentType.
const (
	ArgumentStringArgumentTypeArgumentString ArgumentStringArgumentType = "ArgumentString"
)

// Defines values for ArgumentTimeWindowArgumentType.
const (
	ArgumentTimeWindowArgumentTypeArgumentTimeWindow ArgumentTimeWindowArgumentType = "ArgumentTimeWindow"
)

// Defines values for ArgumentTopologyPromQLMetricArgumentType.
const (
	ArgumentTopologyPromQLMetricArgumentTypeArgumentTopologyPromQLMetric ArgumentTopologyPromQLMetricArgumentType = "ArgumentTopologyPromQLMetric"
)

// Defines values for ArgumentTopologyQueryArgumentType.
const (
	ArgumentTopologyQueryArgumentTypeArgumentTopologyQuery ArgumentTopologyQueryArgumentType = "ArgumentTopologyQuery"
)

// Defines values for ComparatorWithoutEquality.
const (
	GT  ComparatorWithoutEquality = "GT"
	GTE ComparatorWithoutEquality = "GTE"
	LT  ComparatorWithoutEquality = "LT"
	LTE ComparatorWithoutEquality = "LTE"
)

// Defines values for EmailNotificationChannelType.
const (
	EmailNotificationChannelTypeEmailNotificationChannel EmailNotificationChannelType = "EmailNotificationChannel"
)

// Defines values for EmailNotificationChannelIdType.
const (
	EmailNotificationChannelIdTypeEmailNotificationChannelId EmailNotificationChannelIdType = "EmailNotificationChannelId"
)

// Defines values for ExternalMonitorType.
const (
	ExternalMonitorTypeExternalMonitor ExternalMonitorType = "ExternalMonitor"
)

// Defines values for ExternalMonitorIdType.
const (
	ExternalMonitorIdTypeExternalMonitorId ExternalMonitorIdType = "ExternalMonitorId"
)

// Defines values for FailingHealthState.
const (
	FailingHealthStateCRITICAL  FailingHealthState = "CRITICAL"
	FailingHealthStateDEVIATING FailingHealthState = "DEVIATING"
	FailingHealthStateUNKNOWN   FailingHealthState = "UNKNOWN"
)

// Defines values for GroovyFunctionBodyFunctionType.
const (
	GroovyFunctionBodyFunctionTypeGroovyFunctionBody GroovyFunctionBodyFunctionType = "GroovyFunctionBody"
)

// Defines values for HandlebarsFunctionBodyFunctionType.
const (
	HandlebarsFunctionBodyFunctionTypeHandlebarsFunctionBody HandlebarsFunctionBodyFunctionType = "HandlebarsFunctionBody"
)

// Defines values for MergeStrategy.
const (
	MergePreferMine   MergeStrategy = "MergePreferMine"
	MergePreferTheirs MergeStrategy = "MergePreferTheirs"
	UseMine           MergeStrategy = "UseMine"
	UseTheirs         MergeStrategy = "UseTheirs"
)

// Defines values for MonitorType.
const (
	MonitorTypeMonitor MonitorType = "Monitor"
)

// Defines values for MonitorFunctionCallType.
const (
	MonitorFunctionCallTypeMonitorFunctionCall MonitorFunctionCallType = "MonitorFunctionCall"
)

// Defines values for MonitorIdType.
const (
	MonitorIdTypeMonitorId MonitorIdType = "MonitorId"
)

// Defines values for MonitorStatus.
const (
	MonitorStatusDISABLED MonitorStatus = "DISABLED"
	MonitorStatusENABLED  MonitorStatus = "ENABLED"
)

// Defines values for NativeFunctionBodyFunctionType.
const (
	NativeFunctionBodyFunctionTypeNativeFunctionBody NativeFunctionBodyFunctionType = "NativeFunctionBody"
)

// Defines values for NotificationChannelType.
const (
	NotificationChannelTypeEmailNotificationChannel    NotificationChannelType = "EmailNotificationChannel"
	NotificationChannelTypeOpsgenieNotificationChannel NotificationChannelType = "OpsgenieNotificationChannel"
	NotificationChannelTypeSlackNotificationChannel    NotificationChannelType = "SlackNotificationChannel"
	NotificationChannelTypeTeamsNotificationChannel    NotificationChannelType = "TeamsNotificationChannel"
	NotificationChannelTypeWebhookNotificationChannel  NotificationChannelType = "WebhookNotificationChannel"
)

// Defines values for NotificationConfigurationType.
const (
	NotificationConfigurationTypeNotificationConfiguration NotificationConfigurationType = "NotificationConfiguration"
)

// Defines values for NotificationConfigurationStatus.
const (
	NotificationConfigurationStatusDISABLED NotificationConfigurationStatus = "DISABLED"
	NotificationConfigurationStatusENABLED  NotificationConfigurationStatus = "ENABLED"
)

// Defines values for NotifyOnOptions.
const (
	NotifyOnOptionsCRITICAL             NotifyOnOptions = "CRITICAL"
	NotifyOnOptionsDEVIATINGANDCRITICAL NotifyOnOptions = "DEVIATING_AND_CRITICAL"
)

// Defines values for OpsgenieNotificationChannelType.
const (
	OpsgenieNotificationChannelTypeOpsgenieNotificationChannel OpsgenieNotificationChannelType = "OpsgenieNotificationChannel"
)

// Defines values for OpsgenieNotificationChannelIdType.
const (
	OpsgenieNotificationChannelIdTypeOpsgenieNotificationChannelId OpsgenieNotificationChannelIdType = "OpsgenieNotificationChannelId"
)

// Defines values for OpsgeniePriority.
const (
	P1 OpsgeniePriority = "P1"
	P2 OpsgeniePriority = "P2"
	P3 OpsgeniePriority = "P3"
	P4 OpsgeniePriority = "P4"
	P5 OpsgeniePriority = "P5"
)

// Defines values for OpsgenieRegion.
const (
	EU OpsgenieRegion = "EU"
	US OpsgenieRegion = "US"
)

// Defines values for OpsgenieResponderType.
const (
	ESCALATION OpsgenieResponderType = "ESCALATION"
	SCHEDULE   OpsgenieResponderType = "SCHEDULE"
	TEAM       OpsgenieResponderType = "TEAM"
	USER       OpsgenieResponderType = "USER"
)

// Defines values for OtelComponentMappingType.
const (
	OtelComponentMappingTypeOtelComponentMapping OtelComponentMappingType = "OtelComponentMapping"
)

// Defines values for OtelConditionMappingAction.
const (
	CREATE OtelConditionMappingAction = "CREATE"
	REJECT OtelConditionMappingAction = "REJECT"
)

// Defines values for OtelRelationMappingType.
const (
	OtelRelationMappingTypeOtelRelationMapping OtelRelationMappingType = "OtelRelationMapping"
)

// Defines values for QueryViewType.
const (
	QueryViewTypeQueryView QueryViewType = "QueryView"
)

// Defines values for SettingType.
const (
	SettingTypeEmailNotificationChannel    SettingType = "EmailNotificationChannel"
	SettingTypeExternalMonitor             SettingType = "ExternalMonitor"
	SettingTypeMonitor                     SettingType = "Monitor"
	SettingTypeNotificationConfiguration   SettingType = "NotificationConfiguration"
	SettingTypeOpsgenieNotificationChannel SettingType = "OpsgenieNotificationChannel"
	SettingTypeOtelComponentMapping        SettingType = "OtelComponentMapping"
	SettingTypeOtelRelationMapping         SettingType = "OtelRelationMapping"
	SettingTypeQueryView                   SettingType = "QueryView"
	SettingTypeSlackNotificationChannel    SettingType = "SlackNotificationChannel"
	SettingTypeSync                        SettingType = "Sync"
	SettingTypeTeamsNotificationChannel    SettingType = "TeamsNotificationChannel"
	SettingTypeWebhookNotificationChannel  SettingType = "WebhookNotificationChannel"
)

// Defines values for SettingsEnvelopeType.
const (
	SettingsEnvelopeTypeSettingsEnvelope SettingsEnvelopeType = "SettingsEnvelope"
)

// Defines values for SettingsSnapshotStartType.
const (
	SettingsSnapshotStartTypeSettingsSnapshotStart SettingsSnapshotStartType = "SettingsSnapshotStart"
)

// Defines values for SettingsSnapshotStopType.
const (
	SettingsSnapshotStopTypeSettingsSnapshotStop SettingsSnapshotStopType = "SettingsSnapshotStop"
)

// Defines values for SlackNotificationChannelType.
const (
	SlackNotificationChannelTypeSlackNotificationChannel SlackNotificationChannelType = "SlackNotificationChannel"
)

// Defines values for SlackNotificationChannelIdType.
const (
	SlackNotificationChannelIdTypeSlackNotificationChannelId SlackNotificationChannelIdType = "SlackNotificationChannelId"
)

// Defines values for SyncType.
const (
	SyncTypeSync SyncType = "Sync"
)

// Defines values for SyncActionCreateComponentActionType.
const (
	SyncActionCreateComponentActionTypeSyncActionCreateComponent SyncActionCreateComponentActionType = "SyncActionCreateComponent"
)

// Defines values for SyncActionCreateOnMergeActionType.
const (
	SyncActionCreateOnMergeActionTypeSyncActionCreateOnMerge SyncActionCreateOnMergeActionType = "SyncActionCreateOnMerge"
)

// Defines values for SyncActionCreateRelationActionType.
const (
	SyncActionCreateRelationActionTypeSyncActionCreateRelation SyncActionCreateRelationActionType = "SyncActionCreateRelation"
)

// Defines values for TeamsNotificationChannelType.
const (
	TeamsNotificationChannelTypeTeamsNotificationChannel TeamsNotificationChannelType = "TeamsNotificationChannel"
)

// Defines values for TeamsNotificationChannelIdType.
const (
	TeamsNotificationChannelIdTypeTeamsNotificationChannelId TeamsNotificationChannelIdType = "TeamsNotificationChannelId"
)

// Defines values for WebhookNotificationChannelType.
const (
	WebhookNotificationChannelTypeWebhookNotificationChannel WebhookNotificationChannelType = "WebhookNotificationChannel"
)

// Defines values for WebhookNotificationChannelIdType.
const (
	WebhookNotificationChannelIdTypeWebhookNotificationChannelId WebhookNotificationChannelIdType = "WebhookNotificationChannelId"
)

// Argument defines model for Argument.
type Argument struct {
	ArgumentType string `json:"argumentType"`
	union        json.RawMessage
}

// ArgumentBoolean defines model for ArgumentBoolean.
type ArgumentBoolean struct {
	ArgumentType ArgumentBooleanArgumentType `json:"argumentType"`
	Value        bool                        `json:"value"`
}

// ArgumentBooleanArgumentType defines model for ArgumentBoolean.ArgumentType.
type ArgumentBooleanArgumentType string

// ArgumentComparatorWithoutEquality defines model for ArgumentComparatorWithoutEquality.
type ArgumentComparatorWithoutEquality struct {
	ArgumentType ArgumentComparatorWithoutEqualityArgumentType `json:"argumentType"`
	Value        ComparatorWithoutEquality                     `json:"value"`
}

// ArgumentComparatorWithoutEqualityArgumentType defines model for ArgumentComparatorWithoutEquality.ArgumentType.
type ArgumentComparatorWithoutEqualityArgumentType string

// ArgumentDouble defines model for ArgumentDouble.
type ArgumentDouble struct {
	ArgumentType ArgumentDoubleArgumentType `json:"argumentType"`
	Value        float64                    `json:"value"`
}

// ArgumentDoubleArgumentType defines model for ArgumentDouble.ArgumentType.
type ArgumentDoubleArgumentType string

// ArgumentFailingHealthState defines model for ArgumentFailingHealthState.
type ArgumentFailingHealthState struct {
	ArgumentType ArgumentFailingHealthStateArgumentType `json:"argumentType"`
	Value        FailingHealthState                     `json:"value"`
}

// ArgumentFailingHealthStateArgumentType defines model for ArgumentFailingHealthState.ArgumentType.
type ArgumentFailingHealthStateArgumentType string

// ArgumentLong defines model for ArgumentLong.
type ArgumentLong struct {
	ArgumentType ArgumentLongArgumentType `json:"argumentType"`
	Value        int64                    `json:"value"`
}

// ArgumentLongArgumentType defines model for ArgumentLong.ArgumentType.
type ArgumentLongArgumentType string

// ArgumentPromQLMetric defines model for ArgumentPromQLMetric.
type ArgumentPromQLMetric struct {
	AliasTemplate string                           `json:"aliasTemplate"`
	ArgumentType  ArgumentPromQLMetricArgumentType `json:"argumentType"`
	Query         string                           `json:"query"`
	Unit          string                           `json:"unit"`
}

// ArgumentPromQLMetricArgumentType defines model for ArgumentPromQLMetric.ArgumentType.
type ArgumentPromQLMetricArgumentType string

// ArgumentString defines model for ArgumentString.
type ArgumentString struct {
	ArgumentType ArgumentStringArgumentType `json:"argumentType"`
	Value        string                     `json:"value"`
}

// ArgumentStringArgumentType defines model for ArgumentString.ArgumentType.
type ArgumentStringArgumentType string

// ArgumentTimeWindow defines model for ArgumentTimeWindow.
type ArgumentTimeWindow struct {
	ArgumentType ArgumentTimeWindowArgumentType `json:"argumentType"`
	ValueMs      int64                          `json:"valueMs"`
}

// ArgumentTimeWindowArgumentType defines model for ArgumentTimeWindow.ArgumentType.
type ArgumentTimeWindowArgumentType string

// ArgumentTopologyPromQLMetric defines model for ArgumentTopologyPromQLMetric.
type ArgumentTopologyPromQLMetric struct {
	AliasTemplate string                                   `json:"aliasTemplate"`
	ArgumentType  ArgumentTopologyPromQLMetricArgumentType `json:"argumentType"`
	MetricQuery   string                                   `json:"metricQuery"`
	TopologyQuery string                                   `json:"topologyQuery"`
	Unit          string                                   `json:"unit"`
}

// ArgumentTopologyPromQLMetricArgumentType defines model for ArgumentTopologyPromQLMetric.ArgumentType.
type ArgumentTopologyPromQLMetricArgumentType string

// ArgumentTopologyQuery defines model for ArgumentTopologyQuery.
type ArgumentTopologyQuery struct {
	ArgumentType ArgumentTopologyQueryArgumentType `json:"argumentType"`
	Value        string                            `json:"value"`
}

// ArgumentTopologyQueryArgumentType defines model for ArgumentTopologyQuery.ArgumentType.
type ArgumentTopologyQueryArgumentType string

// ComparatorWithoutEquality defines model for ComparatorWithoutEquality.
type ComparatorWithoutEquality string

// EmailNotificationChannel defines model for EmailNotificationChannel.
type EmailNotificationChannel struct {
	Cc []string `json:"cc"`

	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64 `json:"createdTimeStamp"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id SettingId `json:"id"`

	// LastUpdateTimestamp The timestamp of when the setting was last updated.
	LastUpdateTimestamp int      `json:"lastUpdateTimestamp"`
	Shard               Shard    `json:"shard"`
	SubjectPrefix       *string  `json:"subjectPrefix,omitempty"`
	To                  []string `json:"to"`

	// Type The combination of type+id is a unique identification for a setting
	Type EmailNotificationChannelType `json:"type"`
}

// EmailNotificationChannelType The combination of type+id is a unique identification for a setting
type EmailNotificationChannelType string

// EmailNotificationChannelId defines model for EmailNotificationChannelId.
type EmailNotificationChannelId struct {
	Id   string                         `json:"id"`
	Type EmailNotificationChannelIdType `json:"type"`
}

// EmailNotificationChannelIdType defines model for EmailNotificationChannelId.Type.
type EmailNotificationChannelIdType string

// ExternalMonitor defines model for ExternalMonitor.
type ExternalMonitor struct {
	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64  `json:"createdTimeStamp"`
	HealthStreamUrn  string `json:"healthStreamUrn"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id         SettingId `json:"id"`
	Identifier *string   `json:"identifier,omitempty"`

	// Name The name of the setting.
	Name            string   `json:"name"`
	RemediationHint *string  `json:"remediationHint,omitempty"`
	Shard           Shard    `json:"shard"`
	Tags            []string `json:"tags"`

	// Type The combination of type+id is a unique identification for a setting
	Type ExternalMonitorType `json:"type"`
}

// ExternalMonitorType The combination of type+id is a unique identification for a setting
type ExternalMonitorType string

// ExternalMonitorId defines model for ExternalMonitorId.
type ExternalMonitorId struct {
	Id   string                `json:"id"`
	Type ExternalMonitorIdType `json:"type"`
}

// ExternalMonitorIdType defines model for ExternalMonitorId.Type.
type ExternalMonitorIdType string

// FailingHealthState defines model for FailingHealthState.
type FailingHealthState string

// FunctionBody defines model for FunctionBody.
type FunctionBody struct {
	FunctionType string `json:"functionType"`
	union        json.RawMessage
}

// FunctionCall defines model for FunctionCall.
type FunctionCall struct {
	union json.RawMessage
}

// GroovyFunctionBody defines model for GroovyFunctionBody.
type GroovyFunctionBody struct {
	FunctionBody string                         `json:"functionBody"`
	FunctionType GroovyFunctionBodyFunctionType `json:"functionType"`
	Name         string                         `json:"name"`
}

// GroovyFunctionBodyFunctionType defines model for GroovyFunctionBody.FunctionType.
type GroovyFunctionBodyFunctionType string

// HandlebarsFunctionBody defines model for HandlebarsFunctionBody.
type HandlebarsFunctionBody struct {
	FunctionBody string                             `json:"functionBody"`
	FunctionType HandlebarsFunctionBodyFunctionType `json:"functionType"`
	Name         string                             `json:"name"`
}

// HandlebarsFunctionBodyFunctionType defines model for HandlebarsFunctionBody.FunctionType.
type HandlebarsFunctionBodyFunctionType string

// IdExtractorFunctionBody defines model for IdExtractorFunctionBody.
type IdExtractorFunctionBody struct {
	union json.RawMessage
}

// MergeStrategy defines model for MergeStrategy.
type MergeStrategy string

// Monitor defines model for Monitor.
type Monitor struct {
	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64               `json:"createdTimeStamp"`
	Dummy            *bool               `json:"dummy,omitempty"`
	FunctionCall     MonitorFunctionCall `json:"functionCall"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id              SettingId `json:"id"`
	Identifier      *string   `json:"identifier,omitempty"`
	IntervalSeconds int       `json:"intervalSeconds"`

	// Name The name of the setting.
	Name            string        `json:"name"`
	RemediationHint *string       `json:"remediationHint,omitempty"`
	Shard           Shard         `json:"shard"`
	Status          MonitorStatus `json:"status"`
	Tags            []string      `json:"tags"`

	// Type The combination of type+id is a unique identification for a setting
	Type MonitorType `json:"type"`
}

// MonitorType The combination of type+id is a unique identification for a setting
type MonitorType string

// MonitorArgument defines model for MonitorArgument.
type MonitorArgument struct {
	union json.RawMessage
}

// MonitorFunctionBody defines model for MonitorFunctionBody.
type MonitorFunctionBody struct {
	union json.RawMessage
}

// MonitorFunctionCall defines model for MonitorFunctionCall.
type MonitorFunctionCall struct {
	Arguments map[string]MonitorArgument `json:"arguments"`
	Body      MonitorFunctionBody        `json:"body"`
	Type      MonitorFunctionCallType    `json:"type"`
}

// MonitorFunctionCallType defines model for MonitorFunctionCall.Type.
type MonitorFunctionCallType string

// MonitorId defines model for MonitorId.
type MonitorId struct {
	Id   string        `json:"id"`
	Type MonitorIdType `json:"type"`
}

// MonitorIdType defines model for MonitorId.Type.
type MonitorIdType string

// MonitorPresentation defines model for MonitorPresentation.
type MonitorPresentation struct {
	union json.RawMessage
}

// MonitorPresentationId defines model for MonitorPresentationId.
type MonitorPresentationId struct {
	union json.RawMessage
}

// MonitorStatus defines model for MonitorStatus.
type MonitorStatus string

// NativeFunctionBody defines model for NativeFunctionBody.
type NativeFunctionBody struct {
	FunctionRef  string                         `json:"functionRef"`
	FunctionType NativeFunctionBodyFunctionType `json:"functionType"`
	Name         string                         `json:"name"`
}

// NativeFunctionBodyFunctionType defines model for NativeFunctionBody.FunctionType.
type NativeFunctionBodyFunctionType string

// NotificationChannel defines model for NotificationChannel.
type NotificationChannel struct {
	union json.RawMessage
}

// NotificationChannelId defines model for NotificationChannelId.
type NotificationChannelId struct {
	union json.RawMessage
}

// NotificationChannelType defines model for NotificationChannelType.
type NotificationChannelType string

// NotificationConfiguration defines model for NotificationConfiguration.
type NotificationConfiguration struct {
	ChannelIds     []NotificationChannelId `json:"channelIds"`
	ComponentTags  []string                `json:"componentTags"`
	ComponentTypes []string                `json:"componentTypes"`

	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64 `json:"createdTimeStamp"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id         SettingId `json:"id"`
	Identifier *string   `json:"identifier,omitempty"`

	// Name The name of the setting.
	Name                 string                          `json:"name"`
	NotifyMonitorTags    []string                        `json:"notifyMonitorTags"`
	NotifyMonitors       []MonitorPresentationId         `json:"notifyMonitors"`
	NotifyOnHealthStates NotifyOnOptions                 `json:"notifyOnHealthStates"`
	Shard                Shard                           `json:"shard"`
	Status               NotificationConfigurationStatus `json:"status"`

	// Type The combination of type+id is a unique identification for a setting
	Type NotificationConfigurationType `json:"type"`
}

// NotificationConfigurationType The combination of type+id is a unique identification for a setting
type NotificationConfigurationType string

// NotificationConfigurationStatus defines model for NotificationConfigurationStatus.
type NotificationConfigurationStatus string

// NotifyOnOptions defines model for NotifyOnOptions.
type NotifyOnOptions string

// OpsgenieNotificationChannel defines model for OpsgenieNotificationChannel.
type OpsgenieNotificationChannel struct {
	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64  `json:"createdTimeStamp"`
	GenieKey         string `json:"genieKey"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id SettingId `json:"id"`

	// LastUpdateTimestamp The timestamp of when the setting was last updated.
	LastUpdateTimestamp int                 `json:"lastUpdateTimestamp"`
	Priority            OpsgeniePriority    `json:"priority"`
	Region              OpsgenieRegion      `json:"region"`
	Responders          []OpsgenieResponder `json:"responders"`
	Shard               Shard               `json:"shard"`

	// Type The combination of type+id is a unique identification for a setting
	Type OpsgenieNotificationChannelType `json:"type"`
}

// OpsgenieNotificationChannelType The combination of type+id is a unique identification for a setting
type OpsgenieNotificationChannelType string

// OpsgenieNotificationChannelId defines model for OpsgenieNotificationChannelId.
type OpsgenieNotificationChannelId struct {
	Id   string                            `json:"id"`
	Type OpsgenieNotificationChannelIdType `json:"type"`
}

// OpsgenieNotificationChannelIdType defines model for OpsgenieNotificationChannelId.Type.
type OpsgenieNotificationChannelIdType string

// OpsgeniePriority defines model for OpsgeniePriority.
type OpsgeniePriority string

// OpsgenieRegion defines model for OpsgenieRegion.
type OpsgenieRegion string

// OpsgenieResponder defines model for OpsgenieResponder.
type OpsgenieResponder struct {
	Responder     string                `json:"responder"`
	ResponderType OpsgenieResponderType `json:"responderType"`
}

// OpsgenieResponderType defines model for OpsgenieResponderType.
type OpsgenieResponderType string

// OtelBooleanExpression A Cell expression that must return a boolean
type OtelBooleanExpression struct {
	Expression string `json:"expression"`
}

// OtelComponentMapping defines model for OtelComponentMapping.
type OtelComponentMapping struct {
	Conditions []OtelConditionMapping `json:"conditions"`

	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64 `json:"createdTimeStamp"`
	ExpireAfterMs    int64 `json:"expireAfterMs"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id     SettingId                  `json:"id"`
	Name   string                     `json:"name"`
	Output OtelComponentMappingOutput `json:"output"`
	Shard  Shard                      `json:"shard"`

	// Type The combination of type+id is a unique identification for a setting
	Type OtelComponentMappingType `json:"type"`
	Vars *[]OtelVariableMapping   `json:"vars,omitempty"`
}

// OtelComponentMappingType The combination of type+id is a unique identification for a setting
type OtelComponentMappingType string

// OtelComponentMappingFieldMapping defines model for OtelComponentMappingFieldMapping.
type OtelComponentMappingFieldMapping struct {
	AdditionalIdentifiers *[]OtelStringExpression `json:"additionalIdentifiers,omitempty"`
	Tags                  *[]OtelTagMapping       `json:"tags,omitempty"`

	// Version An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	Version *OtelStringExpression `json:"version,omitempty"`
}

// OtelComponentMappingOutput defines model for OtelComponentMappingOutput.
type OtelComponentMappingOutput struct {
	// DomainIdentifier An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	DomainIdentifier *OtelStringExpression `json:"domainIdentifier,omitempty"`

	// DomainName An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	DomainName OtelStringExpression `json:"domainName"`

	// Identifier An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	Identifier OtelStringExpression `json:"identifier"`

	// LayerIdentifier An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	LayerIdentifier *OtelStringExpression `json:"layerIdentifier,omitempty"`

	// LayerName An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	LayerName OtelStringExpression `json:"layerName"`

	// Name An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	Name     OtelStringExpression              `json:"name"`
	Optional *OtelComponentMappingFieldMapping `json:"optional,omitempty"`
	Required *OtelComponentMappingFieldMapping `json:"required,omitempty"`

	// TypeIdentifier An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	TypeIdentifier *OtelStringExpression `json:"typeIdentifier,omitempty"`

	// TypeName An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	TypeName OtelStringExpression `json:"typeName"`
}

// OtelConditionMapping defines model for OtelConditionMapping.
type OtelConditionMapping struct {
	Action OtelConditionMappingAction `json:"action"`

	// Expression A Cell expression that must return a boolean
	Expression OtelBooleanExpression `json:"expression"`
}

// OtelConditionMappingAction defines model for OtelConditionMappingAction.
type OtelConditionMappingAction string

// OtelMapping defines model for OtelMapping.
type OtelMapping struct {
	union json.RawMessage
}

// OtelRelationMapping defines model for OtelRelationMapping.
type OtelRelationMapping struct {
	Conditions []OtelConditionMapping `json:"conditions"`

	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64 `json:"createdTimeStamp"`
	ExpireAfterMs    int64 `json:"expireAfterMs"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id     SettingId                 `json:"id"`
	Name   string                    `json:"name"`
	Output OtelRelationMappingOutput `json:"output"`
	Shard  Shard                     `json:"shard"`

	// Type The combination of type+id is a unique identification for a setting
	Type OtelRelationMappingType `json:"type"`
	Vars *[]OtelVariableMapping  `json:"vars,omitempty"`
}

// OtelRelationMappingType The combination of type+id is a unique identification for a setting
type OtelRelationMappingType string

// OtelRelationMappingOutput defines model for OtelRelationMappingOutput.
type OtelRelationMappingOutput struct {
	// SourceId An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	SourceId OtelStringExpression `json:"sourceId"`

	// TargetId An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	TargetId OtelStringExpression `json:"targetId"`

	// TypeIdentifier An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	TypeIdentifier *OtelStringExpression `json:"typeIdentifier,omitempty"`

	// TypeName An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	TypeName OtelStringExpression `json:"typeName"`
}

// OtelStringExpression An expression that must produce a string. It must be one of these formats:
//   - A plain string, for example `"this is a plain string"`
//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
//
// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
type OtelStringExpression struct {
	Expression string `json:"expression"`
}

// OtelTagMapping Defines how a tag should be mapped from an input source to an output target, optionally using a regex pattern.
type OtelTagMapping struct {
	// Pattern Optional regex pattern applied to the source value. Capturing groups can be referenced in the target (e.g., ${1}).
	Pattern *string `json:"pattern,omitempty"`

	// Source An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	Source OtelStringExpression `json:"source"`

	// Target Name of the target tag key to which the value should be mapped.
	Target string `json:"target"`
}

// OtelVariableMapping defines model for OtelVariableMapping.
type OtelVariableMapping struct {
	Name string `json:"name"`

	// Value An expression that must produce a string. It must be one of these formats:
	//   - A plain string, for example `"this is a plain string"`
	//   - A string containing a CEL expression within curly braces `${}`, for example "a string with a cell expression: `${input.tags.namespace}"`
	// A string with only a cell expression is also valid as long as it is within a `${}` section, for example `"${input.tags.namespace}"`.
	Value OtelStringExpression `json:"value"`
}

// QueryView defines model for QueryView.
type QueryView struct {
	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64 `json:"createdTimeStamp"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id SettingId `json:"id"`

	// Name The name of the setting.
	Name          string `json:"name"`
	Shard         Shard  `json:"shard"`
	TopologyQuery string `json:"topologyQuery"`

	// Type The combination of type+id is a unique identification for a setting
	Type QueryViewType `json:"type"`
}

// QueryViewType The combination of type+id is a unique identification for a setting
type QueryViewType string

// Setting defines model for Setting.
type Setting struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// SettingBase defines model for SettingBase.
type SettingBase struct {
	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64 `json:"createdTimeStamp"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id    SettingId `json:"id"`
	Shard Shard     `json:"shard"`
}

// SettingId A Setting is uniquely identified by the combination of type+id
type SettingId = string

// SettingType defines model for SettingType.
type SettingType string

// SettingsEnvelope defines model for SettingsEnvelope.
type SettingsEnvelope struct {
	// Id UUID to match snapshot start, stop and envelope
	Id      string               `json:"id"`
	Setting Setting              `json:"setting"`
	Type    SettingsEnvelopeType `json:"type"`
}

// SettingsEnvelopeType defines model for SettingsEnvelope.Type.
type SettingsEnvelopeType string

// SettingsProtocol defines model for SettingsProtocol.
type SettingsProtocol struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// SettingsSnapshotStart defines model for SettingsSnapshotStart.
type SettingsSnapshotStart struct {
	// Id UUID to match snapshot start, stop and envelope
	Id          string                    `json:"id"`
	SettingType SettingType               `json:"settingType"`
	Type        SettingsSnapshotStartType `json:"type"`
}

// SettingsSnapshotStartType defines model for SettingsSnapshotStart.Type.
type SettingsSnapshotStartType string

// SettingsSnapshotStop defines model for SettingsSnapshotStop.
type SettingsSnapshotStop struct {
	// Id UUID to match snapshot start, stop and envelope
	Id   string                   `json:"id"`
	Type SettingsSnapshotStopType `json:"type"`
}

// SettingsSnapshotStopType defines model for SettingsSnapshotStop.Type.
type SettingsSnapshotStopType string

// Shard defines model for Shard.
type Shard = int32

// SlackNotificationChannel defines model for SlackNotificationChannel.
type SlackNotificationChannel struct {
	AccessToken string `json:"accessToken"`

	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64 `json:"createdTimeStamp"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id SettingId `json:"id"`

	// LastUpdateTimestamp The timestamp of when the setting was last updated.
	LastUpdateTimestamp int     `json:"lastUpdateTimestamp"`
	Shard               Shard   `json:"shard"`
	SlackChannel        *string `json:"slackChannel,omitempty"`
	SlackChannelId      *string `json:"slackChannelId,omitempty"`
	SlackWorkspace      string  `json:"slackWorkspace"`

	// Type The combination of type+id is a unique identification for a setting
	Type SlackNotificationChannelType `json:"type"`
}

// SlackNotificationChannelType The combination of type+id is a unique identification for a setting
type SlackNotificationChannelType string

// SlackNotificationChannelId defines model for SlackNotificationChannelId.
type SlackNotificationChannelId struct {
	Id   string                         `json:"id"`
	Type SlackNotificationChannelIdType `json:"type"`
}

// SlackNotificationChannelIdType defines model for SlackNotificationChannelId.Type.
type SlackNotificationChannelIdType string

// Sync defines model for Sync.
type Sync struct {
	AutoExpireElements   bool                    `json:"autoExpireElements"`
	ComponentActions     []SyncActionComponent   `json:"componentActions"`
	ComponentIdExtractor IdExtractorFunctionBody `json:"componentIdExtractor"`

	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp       int64               `json:"createdTimeStamp"`
	DefaultComponentAction SyncActionComponent `json:"defaultComponentAction"`
	DefaultRelationAction  SyncActionRelation  `json:"defaultRelationAction"`
	ExpireElementsAfterMs  int64               `json:"expireElementsAfterMs"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id              SettingId `json:"id"`
	IntegrationType string    `json:"integrationType"`

	// Name The name of the setting.
	Name                string                  `json:"name"`
	RelationActions     []SyncActionRelation    `json:"relationActions"`
	RelationIdExtractor IdExtractorFunctionBody `json:"relationIdExtractor"`
	Shard               Shard                   `json:"shard"`
	Topic               string                  `json:"topic"`

	// Type The combination of type+id is a unique identification for a setting
	Type SyncType `json:"type"`
}

// SyncType The combination of type+id is a unique identification for a setting
type SyncType string

// SyncAction defines model for SyncAction.
type SyncAction struct {
	ActionType string `json:"actionType"`
	union      json.RawMessage
}

// SyncActionComponent defines model for SyncActionComponent.
type SyncActionComponent struct {
	union json.RawMessage
}

// SyncActionCreate defines model for SyncActionCreate.
type SyncActionCreate struct {
	union json.RawMessage
}

// SyncActionCreateComponent defines model for SyncActionCreateComponent.
type SyncActionCreateComponent struct {
	ActionType       SyncActionCreateComponentActionType `json:"actionType"`
	MappingFunction  *GroovyFunctionBody                 `json:"mappingFunction,omitempty"`
	MergeStrategy    MergeStrategy                       `json:"mergeStrategy"`
	TemplateFunction HandlebarsFunctionBody              `json:"templateFunction"`
	Type             string                              `json:"type"`
}

// SyncActionCreateComponentActionType defines model for SyncActionCreateComponent.ActionType.
type SyncActionCreateComponentActionType string

// SyncActionCreateOnMerge defines model for SyncActionCreateOnMerge.
type SyncActionCreateOnMerge struct {
	ActionType SyncActionCreateOnMergeActionType `json:"actionType"`
	Type       string                            `json:"type"`
}

// SyncActionCreateOnMergeActionType defines model for SyncActionCreateOnMerge.ActionType.
type SyncActionCreateOnMergeActionType string

// SyncActionCreateRelation defines model for SyncActionCreateRelation.
type SyncActionCreateRelation struct {
	ActionType       SyncActionCreateRelationActionType `json:"actionType"`
	MappingFunction  *GroovyFunctionBody                `json:"mappingFunction,omitempty"`
	MergeStrategy    MergeStrategy                      `json:"mergeStrategy"`
	TemplateFunction HandlebarsFunctionBody             `json:"templateFunction"`
	Type             string                             `json:"type"`
}

// SyncActionCreateRelationActionType defines model for SyncActionCreateRelation.ActionType.
type SyncActionCreateRelationActionType string

// SyncActionRelation defines model for SyncActionRelation.
type SyncActionRelation struct {
	union json.RawMessage
}

// TeamsNotificationChannel defines model for TeamsNotificationChannel.
type TeamsNotificationChannel struct {
	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64 `json:"createdTimeStamp"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id SettingId `json:"id"`

	// LastUpdateTimestamp The timestamp of when the setting was last updated.
	LastUpdateTimestamp int   `json:"lastUpdateTimestamp"`
	Shard               Shard `json:"shard"`

	// Type The combination of type+id is a unique identification for a setting
	Type TeamsNotificationChannelType `json:"type"`
	Url  string                       `json:"url"`
}

// TeamsNotificationChannelType The combination of type+id is a unique identification for a setting
type TeamsNotificationChannelType string

// TeamsNotificationChannelId defines model for TeamsNotificationChannelId.
type TeamsNotificationChannelId struct {
	Id   string                         `json:"id"`
	Type TeamsNotificationChannelIdType `json:"type"`
}

// TeamsNotificationChannelIdType defines model for TeamsNotificationChannelId.Type.
type TeamsNotificationChannelIdType string

// WebhookNotificationChannel defines model for WebhookNotificationChannel.
type WebhookNotificationChannel struct {
	// CreatedTimeStamp The timestamp of when the setting was created.
	CreatedTimeStamp int64 `json:"createdTimeStamp"`

	// Id A Setting is uniquely identified by the combination of type+id
	Id SettingId `json:"id"`

	// LastUpdateTimestamp The timestamp of when the setting was last updated.
	LastUpdateTimestamp int               `json:"lastUpdateTimestamp"`
	Shard               Shard             `json:"shard"`
	Tags                map[string]string `json:"tags"`
	Token               string            `json:"token"`

	// Type The combination of type+id is a unique identification for a setting
	Type      WebhookNotificationChannelType `json:"type"`
	Url       string                         `json:"url"`
	VerifySsl bool                           `json:"verifySsl"`
}

// WebhookNotificationChannelType The combination of type+id is a unique identification for a setting
type WebhookNotificationChannelType string

// WebhookNotificationChannelId defines model for WebhookNotificationChannelId.
type WebhookNotificationChannelId struct {
	Id   string                           `json:"id"`
	Type WebhookNotificationChannelIdType `json:"type"`
}

// WebhookNotificationChannelIdType defines model for WebhookNotificationChannelId.Type.
type WebhookNotificationChannelIdType string

// AsMonitorArgument returns the union data inside the Argument as a MonitorArgument
func (t Argument) AsMonitorArgument() (MonitorArgument, error) {
	var body MonitorArgument
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitorArgument overwrites any union data inside the Argument as the provided MonitorArgument
func (t *Argument) FromMonitorArgument(v MonitorArgument) error {
	t.ArgumentType = "MonitorArgument"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitorArgument performs a merge with any union data inside the Argument, using the provided MonitorArgument
func (t *Argument) MergeMonitorArgument(v MonitorArgument) error {
	t.ArgumentType = "MonitorArgument"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Argument) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"argumentType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Argument) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "MonitorArgument":
		return t.AsMonitorArgument()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Argument) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["argumentType"], err = json.Marshal(t.ArgumentType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'argumentType': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Argument) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["argumentType"]; found {
		err = json.Unmarshal(raw, &t.ArgumentType)
		if err != nil {
			return fmt.Errorf("error reading 'argumentType': %w", err)
		}
	}

	return err
}

// AsMonitorFunctionBody returns the union data inside the FunctionBody as a MonitorFunctionBody
func (t FunctionBody) AsMonitorFunctionBody() (MonitorFunctionBody, error) {
	var body MonitorFunctionBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitorFunctionBody overwrites any union data inside the FunctionBody as the provided MonitorFunctionBody
func (t *FunctionBody) FromMonitorFunctionBody(v MonitorFunctionBody) error {
	t.FunctionType = "MonitorFunctionBody"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitorFunctionBody performs a merge with any union data inside the FunctionBody, using the provided MonitorFunctionBody
func (t *FunctionBody) MergeMonitorFunctionBody(v MonitorFunctionBody) error {
	t.FunctionType = "MonitorFunctionBody"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdExtractorFunctionBody returns the union data inside the FunctionBody as a IdExtractorFunctionBody
func (t FunctionBody) AsIdExtractorFunctionBody() (IdExtractorFunctionBody, error) {
	var body IdExtractorFunctionBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdExtractorFunctionBody overwrites any union data inside the FunctionBody as the provided IdExtractorFunctionBody
func (t *FunctionBody) FromIdExtractorFunctionBody(v IdExtractorFunctionBody) error {
	t.FunctionType = "IdExtractorFunctionBody"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdExtractorFunctionBody performs a merge with any union data inside the FunctionBody, using the provided IdExtractorFunctionBody
func (t *FunctionBody) MergeIdExtractorFunctionBody(v IdExtractorFunctionBody) error {
	t.FunctionType = "IdExtractorFunctionBody"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHandlebarsFunctionBody returns the union data inside the FunctionBody as a HandlebarsFunctionBody
func (t FunctionBody) AsHandlebarsFunctionBody() (HandlebarsFunctionBody, error) {
	var body HandlebarsFunctionBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHandlebarsFunctionBody overwrites any union data inside the FunctionBody as the provided HandlebarsFunctionBody
func (t *FunctionBody) FromHandlebarsFunctionBody(v HandlebarsFunctionBody) error {
	t.FunctionType = "HandlebarsFunctionBody"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHandlebarsFunctionBody performs a merge with any union data inside the FunctionBody, using the provided HandlebarsFunctionBody
func (t *FunctionBody) MergeHandlebarsFunctionBody(v HandlebarsFunctionBody) error {
	t.FunctionType = "HandlebarsFunctionBody"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroovyFunctionBody returns the union data inside the FunctionBody as a GroovyFunctionBody
func (t FunctionBody) AsGroovyFunctionBody() (GroovyFunctionBody, error) {
	var body GroovyFunctionBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroovyFunctionBody overwrites any union data inside the FunctionBody as the provided GroovyFunctionBody
func (t *FunctionBody) FromGroovyFunctionBody(v GroovyFunctionBody) error {
	t.FunctionType = "GroovyFunctionBody"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroovyFunctionBody performs a merge with any union data inside the FunctionBody, using the provided GroovyFunctionBody
func (t *FunctionBody) MergeGroovyFunctionBody(v GroovyFunctionBody) error {
	t.FunctionType = "GroovyFunctionBody"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNativeFunctionBody returns the union data inside the FunctionBody as a NativeFunctionBody
func (t FunctionBody) AsNativeFunctionBody() (NativeFunctionBody, error) {
	var body NativeFunctionBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFunctionBody overwrites any union data inside the FunctionBody as the provided NativeFunctionBody
func (t *FunctionBody) FromNativeFunctionBody(v NativeFunctionBody) error {
	t.FunctionType = "NativeFunctionBody"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFunctionBody performs a merge with any union data inside the FunctionBody, using the provided NativeFunctionBody
func (t *FunctionBody) MergeNativeFunctionBody(v NativeFunctionBody) error {
	t.FunctionType = "NativeFunctionBody"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FunctionBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"functionType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FunctionBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "GroovyFunctionBody":
		return t.AsGroovyFunctionBody()
	case "HandlebarsFunctionBody":
		return t.AsHandlebarsFunctionBody()
	case "IdExtractorFunctionBody":
		return t.AsIdExtractorFunctionBody()
	case "MonitorFunctionBody":
		return t.AsMonitorFunctionBody()
	case "NativeFunctionBody":
		return t.AsNativeFunctionBody()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FunctionBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["functionType"], err = json.Marshal(t.FunctionType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'functionType': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *FunctionBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["functionType"]; found {
		err = json.Unmarshal(raw, &t.FunctionType)
		if err != nil {
			return fmt.Errorf("error reading 'functionType': %w", err)
		}
	}

	return err
}

// AsMonitorFunctionCall returns the union data inside the FunctionCall as a MonitorFunctionCall
func (t FunctionCall) AsMonitorFunctionCall() (MonitorFunctionCall, error) {
	var body MonitorFunctionCall
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitorFunctionCall overwrites any union data inside the FunctionCall as the provided MonitorFunctionCall
func (t *FunctionCall) FromMonitorFunctionCall(v MonitorFunctionCall) error {
	v.Type = "MonitorFunctionCall"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitorFunctionCall performs a merge with any union data inside the FunctionCall, using the provided MonitorFunctionCall
func (t *FunctionCall) MergeMonitorFunctionCall(v MonitorFunctionCall) error {
	v.Type = "MonitorFunctionCall"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FunctionCall) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FunctionCall) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "MonitorFunctionCall":
		return t.AsMonitorFunctionCall()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FunctionCall) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FunctionCall) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNativeFunctionBody returns the union data inside the IdExtractorFunctionBody as a NativeFunctionBody
func (t IdExtractorFunctionBody) AsNativeFunctionBody() (NativeFunctionBody, error) {
	var body NativeFunctionBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFunctionBody overwrites any union data inside the IdExtractorFunctionBody as the provided NativeFunctionBody
func (t *IdExtractorFunctionBody) FromNativeFunctionBody(v NativeFunctionBody) error {
	v.FunctionType = "NativeFunctionBody"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFunctionBody performs a merge with any union data inside the IdExtractorFunctionBody, using the provided NativeFunctionBody
func (t *IdExtractorFunctionBody) MergeNativeFunctionBody(v NativeFunctionBody) error {
	v.FunctionType = "NativeFunctionBody"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroovyFunctionBody returns the union data inside the IdExtractorFunctionBody as a GroovyFunctionBody
func (t IdExtractorFunctionBody) AsGroovyFunctionBody() (GroovyFunctionBody, error) {
	var body GroovyFunctionBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroovyFunctionBody overwrites any union data inside the IdExtractorFunctionBody as the provided GroovyFunctionBody
func (t *IdExtractorFunctionBody) FromGroovyFunctionBody(v GroovyFunctionBody) error {
	v.FunctionType = "GroovyFunctionBody"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroovyFunctionBody performs a merge with any union data inside the IdExtractorFunctionBody, using the provided GroovyFunctionBody
func (t *IdExtractorFunctionBody) MergeGroovyFunctionBody(v GroovyFunctionBody) error {
	v.FunctionType = "GroovyFunctionBody"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IdExtractorFunctionBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"functionType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IdExtractorFunctionBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "GroovyFunctionBody":
		return t.AsGroovyFunctionBody()
	case "NativeFunctionBody":
		return t.AsNativeFunctionBody()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IdExtractorFunctionBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IdExtractorFunctionBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsArgumentBoolean returns the union data inside the MonitorArgument as a ArgumentBoolean
func (t MonitorArgument) AsArgumentBoolean() (ArgumentBoolean, error) {
	var body ArgumentBoolean
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentBoolean overwrites any union data inside the MonitorArgument as the provided ArgumentBoolean
func (t *MonitorArgument) FromArgumentBoolean(v ArgumentBoolean) error {
	v.ArgumentType = "ArgumentBoolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentBoolean performs a merge with any union data inside the MonitorArgument, using the provided ArgumentBoolean
func (t *MonitorArgument) MergeArgumentBoolean(v ArgumentBoolean) error {
	v.ArgumentType = "ArgumentBoolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArgumentDouble returns the union data inside the MonitorArgument as a ArgumentDouble
func (t MonitorArgument) AsArgumentDouble() (ArgumentDouble, error) {
	var body ArgumentDouble
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentDouble overwrites any union data inside the MonitorArgument as the provided ArgumentDouble
func (t *MonitorArgument) FromArgumentDouble(v ArgumentDouble) error {
	v.ArgumentType = "ArgumentDouble"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentDouble performs a merge with any union data inside the MonitorArgument, using the provided ArgumentDouble
func (t *MonitorArgument) MergeArgumentDouble(v ArgumentDouble) error {
	v.ArgumentType = "ArgumentDouble"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArgumentLong returns the union data inside the MonitorArgument as a ArgumentLong
func (t MonitorArgument) AsArgumentLong() (ArgumentLong, error) {
	var body ArgumentLong
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentLong overwrites any union data inside the MonitorArgument as the provided ArgumentLong
func (t *MonitorArgument) FromArgumentLong(v ArgumentLong) error {
	v.ArgumentType = "ArgumentLong"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentLong performs a merge with any union data inside the MonitorArgument, using the provided ArgumentLong
func (t *MonitorArgument) MergeArgumentLong(v ArgumentLong) error {
	v.ArgumentType = "ArgumentLong"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArgumentString returns the union data inside the MonitorArgument as a ArgumentString
func (t MonitorArgument) AsArgumentString() (ArgumentString, error) {
	var body ArgumentString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentString overwrites any union data inside the MonitorArgument as the provided ArgumentString
func (t *MonitorArgument) FromArgumentString(v ArgumentString) error {
	v.ArgumentType = "ArgumentString"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentString performs a merge with any union data inside the MonitorArgument, using the provided ArgumentString
func (t *MonitorArgument) MergeArgumentString(v ArgumentString) error {
	v.ArgumentType = "ArgumentString"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArgumentTimeWindow returns the union data inside the MonitorArgument as a ArgumentTimeWindow
func (t MonitorArgument) AsArgumentTimeWindow() (ArgumentTimeWindow, error) {
	var body ArgumentTimeWindow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentTimeWindow overwrites any union data inside the MonitorArgument as the provided ArgumentTimeWindow
func (t *MonitorArgument) FromArgumentTimeWindow(v ArgumentTimeWindow) error {
	v.ArgumentType = "ArgumentTimeWindow"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentTimeWindow performs a merge with any union data inside the MonitorArgument, using the provided ArgumentTimeWindow
func (t *MonitorArgument) MergeArgumentTimeWindow(v ArgumentTimeWindow) error {
	v.ArgumentType = "ArgumentTimeWindow"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArgumentPromQLMetric returns the union data inside the MonitorArgument as a ArgumentPromQLMetric
func (t MonitorArgument) AsArgumentPromQLMetric() (ArgumentPromQLMetric, error) {
	var body ArgumentPromQLMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentPromQLMetric overwrites any union data inside the MonitorArgument as the provided ArgumentPromQLMetric
func (t *MonitorArgument) FromArgumentPromQLMetric(v ArgumentPromQLMetric) error {
	v.ArgumentType = "ArgumentPromQLMetric"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentPromQLMetric performs a merge with any union data inside the MonitorArgument, using the provided ArgumentPromQLMetric
func (t *MonitorArgument) MergeArgumentPromQLMetric(v ArgumentPromQLMetric) error {
	v.ArgumentType = "ArgumentPromQLMetric"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArgumentComparatorWithoutEquality returns the union data inside the MonitorArgument as a ArgumentComparatorWithoutEquality
func (t MonitorArgument) AsArgumentComparatorWithoutEquality() (ArgumentComparatorWithoutEquality, error) {
	var body ArgumentComparatorWithoutEquality
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentComparatorWithoutEquality overwrites any union data inside the MonitorArgument as the provided ArgumentComparatorWithoutEquality
func (t *MonitorArgument) FromArgumentComparatorWithoutEquality(v ArgumentComparatorWithoutEquality) error {
	v.ArgumentType = "ArgumentComparatorWithoutEquality"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentComparatorWithoutEquality performs a merge with any union data inside the MonitorArgument, using the provided ArgumentComparatorWithoutEquality
func (t *MonitorArgument) MergeArgumentComparatorWithoutEquality(v ArgumentComparatorWithoutEquality) error {
	v.ArgumentType = "ArgumentComparatorWithoutEquality"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArgumentFailingHealthState returns the union data inside the MonitorArgument as a ArgumentFailingHealthState
func (t MonitorArgument) AsArgumentFailingHealthState() (ArgumentFailingHealthState, error) {
	var body ArgumentFailingHealthState
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentFailingHealthState overwrites any union data inside the MonitorArgument as the provided ArgumentFailingHealthState
func (t *MonitorArgument) FromArgumentFailingHealthState(v ArgumentFailingHealthState) error {
	v.ArgumentType = "ArgumentFailingHealthState"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentFailingHealthState performs a merge with any union data inside the MonitorArgument, using the provided ArgumentFailingHealthState
func (t *MonitorArgument) MergeArgumentFailingHealthState(v ArgumentFailingHealthState) error {
	v.ArgumentType = "ArgumentFailingHealthState"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArgumentTopologyQuery returns the union data inside the MonitorArgument as a ArgumentTopologyQuery
func (t MonitorArgument) AsArgumentTopologyQuery() (ArgumentTopologyQuery, error) {
	var body ArgumentTopologyQuery
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentTopologyQuery overwrites any union data inside the MonitorArgument as the provided ArgumentTopologyQuery
func (t *MonitorArgument) FromArgumentTopologyQuery(v ArgumentTopologyQuery) error {
	v.ArgumentType = "ArgumentTopologyQuery"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentTopologyQuery performs a merge with any union data inside the MonitorArgument, using the provided ArgumentTopologyQuery
func (t *MonitorArgument) MergeArgumentTopologyQuery(v ArgumentTopologyQuery) error {
	v.ArgumentType = "ArgumentTopologyQuery"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArgumentTopologyPromQLMetric returns the union data inside the MonitorArgument as a ArgumentTopologyPromQLMetric
func (t MonitorArgument) AsArgumentTopologyPromQLMetric() (ArgumentTopologyPromQLMetric, error) {
	var body ArgumentTopologyPromQLMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArgumentTopologyPromQLMetric overwrites any union data inside the MonitorArgument as the provided ArgumentTopologyPromQLMetric
func (t *MonitorArgument) FromArgumentTopologyPromQLMetric(v ArgumentTopologyPromQLMetric) error {
	v.ArgumentType = "ArgumentTopologyPromQLMetric"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArgumentTopologyPromQLMetric performs a merge with any union data inside the MonitorArgument, using the provided ArgumentTopologyPromQLMetric
func (t *MonitorArgument) MergeArgumentTopologyPromQLMetric(v ArgumentTopologyPromQLMetric) error {
	v.ArgumentType = "ArgumentTopologyPromQLMetric"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MonitorArgument) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"argumentType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MonitorArgument) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ArgumentBoolean":
		return t.AsArgumentBoolean()
	case "ArgumentComparatorWithoutEquality":
		return t.AsArgumentComparatorWithoutEquality()
	case "ArgumentDouble":
		return t.AsArgumentDouble()
	case "ArgumentFailingHealthState":
		return t.AsArgumentFailingHealthState()
	case "ArgumentLong":
		return t.AsArgumentLong()
	case "ArgumentPromQLMetric":
		return t.AsArgumentPromQLMetric()
	case "ArgumentString":
		return t.AsArgumentString()
	case "ArgumentTimeWindow":
		return t.AsArgumentTimeWindow()
	case "ArgumentTopologyPromQLMetric":
		return t.AsArgumentTopologyPromQLMetric()
	case "ArgumentTopologyQuery":
		return t.AsArgumentTopologyQuery()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MonitorArgument) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MonitorArgument) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNativeFunctionBody returns the union data inside the MonitorFunctionBody as a NativeFunctionBody
func (t MonitorFunctionBody) AsNativeFunctionBody() (NativeFunctionBody, error) {
	var body NativeFunctionBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFunctionBody overwrites any union data inside the MonitorFunctionBody as the provided NativeFunctionBody
func (t *MonitorFunctionBody) FromNativeFunctionBody(v NativeFunctionBody) error {
	v.FunctionType = "NativeFunctionBody"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFunctionBody performs a merge with any union data inside the MonitorFunctionBody, using the provided NativeFunctionBody
func (t *MonitorFunctionBody) MergeNativeFunctionBody(v NativeFunctionBody) error {
	v.FunctionType = "NativeFunctionBody"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroovyFunctionBody returns the union data inside the MonitorFunctionBody as a GroovyFunctionBody
func (t MonitorFunctionBody) AsGroovyFunctionBody() (GroovyFunctionBody, error) {
	var body GroovyFunctionBody
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroovyFunctionBody overwrites any union data inside the MonitorFunctionBody as the provided GroovyFunctionBody
func (t *MonitorFunctionBody) FromGroovyFunctionBody(v GroovyFunctionBody) error {
	v.FunctionType = "GroovyFunctionBody"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroovyFunctionBody performs a merge with any union data inside the MonitorFunctionBody, using the provided GroovyFunctionBody
func (t *MonitorFunctionBody) MergeGroovyFunctionBody(v GroovyFunctionBody) error {
	v.FunctionType = "GroovyFunctionBody"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MonitorFunctionBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"functionType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MonitorFunctionBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "GroovyFunctionBody":
		return t.AsGroovyFunctionBody()
	case "NativeFunctionBody":
		return t.AsNativeFunctionBody()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MonitorFunctionBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MonitorFunctionBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMonitor returns the union data inside the MonitorPresentation as a Monitor
func (t MonitorPresentation) AsMonitor() (Monitor, error) {
	var body Monitor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitor overwrites any union data inside the MonitorPresentation as the provided Monitor
func (t *MonitorPresentation) FromMonitor(v Monitor) error {
	v.Type = "Monitor"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitor performs a merge with any union data inside the MonitorPresentation, using the provided Monitor
func (t *MonitorPresentation) MergeMonitor(v Monitor) error {
	v.Type = "Monitor"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalMonitor returns the union data inside the MonitorPresentation as a ExternalMonitor
func (t MonitorPresentation) AsExternalMonitor() (ExternalMonitor, error) {
	var body ExternalMonitor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalMonitor overwrites any union data inside the MonitorPresentation as the provided ExternalMonitor
func (t *MonitorPresentation) FromExternalMonitor(v ExternalMonitor) error {
	v.Type = "ExternalMonitor"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalMonitor performs a merge with any union data inside the MonitorPresentation, using the provided ExternalMonitor
func (t *MonitorPresentation) MergeExternalMonitor(v ExternalMonitor) error {
	v.Type = "ExternalMonitor"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MonitorPresentation) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MonitorPresentation) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ExternalMonitor":
		return t.AsExternalMonitor()
	case "Monitor":
		return t.AsMonitor()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MonitorPresentation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MonitorPresentation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMonitorId returns the union data inside the MonitorPresentationId as a MonitorId
func (t MonitorPresentationId) AsMonitorId() (MonitorId, error) {
	var body MonitorId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitorId overwrites any union data inside the MonitorPresentationId as the provided MonitorId
func (t *MonitorPresentationId) FromMonitorId(v MonitorId) error {
	v.Type = "MonitorId"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitorId performs a merge with any union data inside the MonitorPresentationId, using the provided MonitorId
func (t *MonitorPresentationId) MergeMonitorId(v MonitorId) error {
	v.Type = "MonitorId"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalMonitorId returns the union data inside the MonitorPresentationId as a ExternalMonitorId
func (t MonitorPresentationId) AsExternalMonitorId() (ExternalMonitorId, error) {
	var body ExternalMonitorId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalMonitorId overwrites any union data inside the MonitorPresentationId as the provided ExternalMonitorId
func (t *MonitorPresentationId) FromExternalMonitorId(v ExternalMonitorId) error {
	v.Type = "ExternalMonitorId"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalMonitorId performs a merge with any union data inside the MonitorPresentationId, using the provided ExternalMonitorId
func (t *MonitorPresentationId) MergeExternalMonitorId(v ExternalMonitorId) error {
	v.Type = "ExternalMonitorId"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MonitorPresentationId) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MonitorPresentationId) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ExternalMonitorId":
		return t.AsExternalMonitorId()
	case "MonitorId":
		return t.AsMonitorId()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MonitorPresentationId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MonitorPresentationId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmailNotificationChannel returns the union data inside the NotificationChannel as a EmailNotificationChannel
func (t NotificationChannel) AsEmailNotificationChannel() (EmailNotificationChannel, error) {
	var body EmailNotificationChannel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailNotificationChannel overwrites any union data inside the NotificationChannel as the provided EmailNotificationChannel
func (t *NotificationChannel) FromEmailNotificationChannel(v EmailNotificationChannel) error {
	v.Type = "EmailNotificationChannel"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailNotificationChannel performs a merge with any union data inside the NotificationChannel, using the provided EmailNotificationChannel
func (t *NotificationChannel) MergeEmailNotificationChannel(v EmailNotificationChannel) error {
	v.Type = "EmailNotificationChannel"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpsgenieNotificationChannel returns the union data inside the NotificationChannel as a OpsgenieNotificationChannel
func (t NotificationChannel) AsOpsgenieNotificationChannel() (OpsgenieNotificationChannel, error) {
	var body OpsgenieNotificationChannel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpsgenieNotificationChannel overwrites any union data inside the NotificationChannel as the provided OpsgenieNotificationChannel
func (t *NotificationChannel) FromOpsgenieNotificationChannel(v OpsgenieNotificationChannel) error {
	v.Type = "OpsgenieNotificationChannel"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpsgenieNotificationChannel performs a merge with any union data inside the NotificationChannel, using the provided OpsgenieNotificationChannel
func (t *NotificationChannel) MergeOpsgenieNotificationChannel(v OpsgenieNotificationChannel) error {
	v.Type = "OpsgenieNotificationChannel"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlackNotificationChannel returns the union data inside the NotificationChannel as a SlackNotificationChannel
func (t NotificationChannel) AsSlackNotificationChannel() (SlackNotificationChannel, error) {
	var body SlackNotificationChannel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlackNotificationChannel overwrites any union data inside the NotificationChannel as the provided SlackNotificationChannel
func (t *NotificationChannel) FromSlackNotificationChannel(v SlackNotificationChannel) error {
	v.Type = "SlackNotificationChannel"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlackNotificationChannel performs a merge with any union data inside the NotificationChannel, using the provided SlackNotificationChannel
func (t *NotificationChannel) MergeSlackNotificationChannel(v SlackNotificationChannel) error {
	v.Type = "SlackNotificationChannel"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamsNotificationChannel returns the union data inside the NotificationChannel as a TeamsNotificationChannel
func (t NotificationChannel) AsTeamsNotificationChannel() (TeamsNotificationChannel, error) {
	var body TeamsNotificationChannel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamsNotificationChannel overwrites any union data inside the NotificationChannel as the provided TeamsNotificationChannel
func (t *NotificationChannel) FromTeamsNotificationChannel(v TeamsNotificationChannel) error {
	v.Type = "TeamsNotificationChannel"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamsNotificationChannel performs a merge with any union data inside the NotificationChannel, using the provided TeamsNotificationChannel
func (t *NotificationChannel) MergeTeamsNotificationChannel(v TeamsNotificationChannel) error {
	v.Type = "TeamsNotificationChannel"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookNotificationChannel returns the union data inside the NotificationChannel as a WebhookNotificationChannel
func (t NotificationChannel) AsWebhookNotificationChannel() (WebhookNotificationChannel, error) {
	var body WebhookNotificationChannel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookNotificationChannel overwrites any union data inside the NotificationChannel as the provided WebhookNotificationChannel
func (t *NotificationChannel) FromWebhookNotificationChannel(v WebhookNotificationChannel) error {
	v.Type = "WebhookNotificationChannel"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookNotificationChannel performs a merge with any union data inside the NotificationChannel, using the provided WebhookNotificationChannel
func (t *NotificationChannel) MergeWebhookNotificationChannel(v WebhookNotificationChannel) error {
	v.Type = "WebhookNotificationChannel"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationChannel) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationChannel) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "EmailNotificationChannel":
		return t.AsEmailNotificationChannel()
	case "OpsgenieNotificationChannel":
		return t.AsOpsgenieNotificationChannel()
	case "SlackNotificationChannel":
		return t.AsSlackNotificationChannel()
	case "TeamsNotificationChannel":
		return t.AsTeamsNotificationChannel()
	case "WebhookNotificationChannel":
		return t.AsWebhookNotificationChannel()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationChannel) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationChannel) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSlackNotificationChannelId returns the union data inside the NotificationChannelId as a SlackNotificationChannelId
func (t NotificationChannelId) AsSlackNotificationChannelId() (SlackNotificationChannelId, error) {
	var body SlackNotificationChannelId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlackNotificationChannelId overwrites any union data inside the NotificationChannelId as the provided SlackNotificationChannelId
func (t *NotificationChannelId) FromSlackNotificationChannelId(v SlackNotificationChannelId) error {
	v.Type = "SlackNotificationChannelId"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlackNotificationChannelId performs a merge with any union data inside the NotificationChannelId, using the provided SlackNotificationChannelId
func (t *NotificationChannelId) MergeSlackNotificationChannelId(v SlackNotificationChannelId) error {
	v.Type = "SlackNotificationChannelId"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookNotificationChannelId returns the union data inside the NotificationChannelId as a WebhookNotificationChannelId
func (t NotificationChannelId) AsWebhookNotificationChannelId() (WebhookNotificationChannelId, error) {
	var body WebhookNotificationChannelId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookNotificationChannelId overwrites any union data inside the NotificationChannelId as the provided WebhookNotificationChannelId
func (t *NotificationChannelId) FromWebhookNotificationChannelId(v WebhookNotificationChannelId) error {
	v.Type = "WebhookNotificationChannelId"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookNotificationChannelId performs a merge with any union data inside the NotificationChannelId, using the provided WebhookNotificationChannelId
func (t *NotificationChannelId) MergeWebhookNotificationChannelId(v WebhookNotificationChannelId) error {
	v.Type = "WebhookNotificationChannelId"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpsgenieNotificationChannelId returns the union data inside the NotificationChannelId as a OpsgenieNotificationChannelId
func (t NotificationChannelId) AsOpsgenieNotificationChannelId() (OpsgenieNotificationChannelId, error) {
	var body OpsgenieNotificationChannelId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpsgenieNotificationChannelId overwrites any union data inside the NotificationChannelId as the provided OpsgenieNotificationChannelId
func (t *NotificationChannelId) FromOpsgenieNotificationChannelId(v OpsgenieNotificationChannelId) error {
	v.Type = "OpsgenieNotificationChannelId"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpsgenieNotificationChannelId performs a merge with any union data inside the NotificationChannelId, using the provided OpsgenieNotificationChannelId
func (t *NotificationChannelId) MergeOpsgenieNotificationChannelId(v OpsgenieNotificationChannelId) error {
	v.Type = "OpsgenieNotificationChannelId"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamsNotificationChannelId returns the union data inside the NotificationChannelId as a TeamsNotificationChannelId
func (t NotificationChannelId) AsTeamsNotificationChannelId() (TeamsNotificationChannelId, error) {
	var body TeamsNotificationChannelId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamsNotificationChannelId overwrites any union data inside the NotificationChannelId as the provided TeamsNotificationChannelId
func (t *NotificationChannelId) FromTeamsNotificationChannelId(v TeamsNotificationChannelId) error {
	v.Type = "TeamsNotificationChannelId"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamsNotificationChannelId performs a merge with any union data inside the NotificationChannelId, using the provided TeamsNotificationChannelId
func (t *NotificationChannelId) MergeTeamsNotificationChannelId(v TeamsNotificationChannelId) error {
	v.Type = "TeamsNotificationChannelId"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailNotificationChannelId returns the union data inside the NotificationChannelId as a EmailNotificationChannelId
func (t NotificationChannelId) AsEmailNotificationChannelId() (EmailNotificationChannelId, error) {
	var body EmailNotificationChannelId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailNotificationChannelId overwrites any union data inside the NotificationChannelId as the provided EmailNotificationChannelId
func (t *NotificationChannelId) FromEmailNotificationChannelId(v EmailNotificationChannelId) error {
	v.Type = "EmailNotificationChannelId"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailNotificationChannelId performs a merge with any union data inside the NotificationChannelId, using the provided EmailNotificationChannelId
func (t *NotificationChannelId) MergeEmailNotificationChannelId(v EmailNotificationChannelId) error {
	v.Type = "EmailNotificationChannelId"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationChannelId) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationChannelId) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "EmailNotificationChannelId":
		return t.AsEmailNotificationChannelId()
	case "OpsgenieNotificationChannelId":
		return t.AsOpsgenieNotificationChannelId()
	case "SlackNotificationChannelId":
		return t.AsSlackNotificationChannelId()
	case "TeamsNotificationChannelId":
		return t.AsTeamsNotificationChannelId()
	case "WebhookNotificationChannelId":
		return t.AsWebhookNotificationChannelId()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationChannelId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationChannelId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOtelComponentMapping returns the union data inside the OtelMapping as a OtelComponentMapping
func (t OtelMapping) AsOtelComponentMapping() (OtelComponentMapping, error) {
	var body OtelComponentMapping
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtelComponentMapping overwrites any union data inside the OtelMapping as the provided OtelComponentMapping
func (t *OtelMapping) FromOtelComponentMapping(v OtelComponentMapping) error {
	v.Type = "OtelComponentMapping"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtelComponentMapping performs a merge with any union data inside the OtelMapping, using the provided OtelComponentMapping
func (t *OtelMapping) MergeOtelComponentMapping(v OtelComponentMapping) error {
	v.Type = "OtelComponentMapping"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtelRelationMapping returns the union data inside the OtelMapping as a OtelRelationMapping
func (t OtelMapping) AsOtelRelationMapping() (OtelRelationMapping, error) {
	var body OtelRelationMapping
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtelRelationMapping overwrites any union data inside the OtelMapping as the provided OtelRelationMapping
func (t *OtelMapping) FromOtelRelationMapping(v OtelRelationMapping) error {
	v.Type = "OtelRelationMapping"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtelRelationMapping performs a merge with any union data inside the OtelMapping, using the provided OtelRelationMapping
func (t *OtelMapping) MergeOtelRelationMapping(v OtelRelationMapping) error {
	v.Type = "OtelRelationMapping"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OtelMapping) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OtelMapping) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "OtelComponentMapping":
		return t.AsOtelComponentMapping()
	case "OtelRelationMapping":
		return t.AsOtelRelationMapping()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OtelMapping) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OtelMapping) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotificationConfiguration returns the union data inside the Setting as a NotificationConfiguration
func (t Setting) AsNotificationConfiguration() (NotificationConfiguration, error) {
	var body NotificationConfiguration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationConfiguration overwrites any union data inside the Setting as the provided NotificationConfiguration
func (t *Setting) FromNotificationConfiguration(v NotificationConfiguration) error {
	t.Type = "NotificationConfiguration"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationConfiguration performs a merge with any union data inside the Setting, using the provided NotificationConfiguration
func (t *Setting) MergeNotificationConfiguration(v NotificationConfiguration) error {
	t.Type = "NotificationConfiguration"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNotificationChannel returns the union data inside the Setting as a NotificationChannel
func (t Setting) AsNotificationChannel() (NotificationChannel, error) {
	var body NotificationChannel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationChannel overwrites any union data inside the Setting as the provided NotificationChannel
func (t *Setting) FromNotificationChannel(v NotificationChannel) error {
	t.Type = "NotificationChannel"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationChannel performs a merge with any union data inside the Setting, using the provided NotificationChannel
func (t *Setting) MergeNotificationChannel(v NotificationChannel) error {
	t.Type = "NotificationChannel"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSync returns the union data inside the Setting as a Sync
func (t Setting) AsSync() (Sync, error) {
	var body Sync
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSync overwrites any union data inside the Setting as the provided Sync
func (t *Setting) FromSync(v Sync) error {
	t.Type = "Sync"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSync performs a merge with any union data inside the Setting, using the provided Sync
func (t *Setting) MergeSync(v Sync) error {
	t.Type = "Sync"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMonitor returns the union data inside the Setting as a Monitor
func (t Setting) AsMonitor() (Monitor, error) {
	var body Monitor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonitor overwrites any union data inside the Setting as the provided Monitor
func (t *Setting) FromMonitor(v Monitor) error {
	t.Type = "Monitor"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMonitor performs a merge with any union data inside the Setting, using the provided Monitor
func (t *Setting) MergeMonitor(v Monitor) error {
	t.Type = "Monitor"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalMonitor returns the union data inside the Setting as a ExternalMonitor
func (t Setting) AsExternalMonitor() (ExternalMonitor, error) {
	var body ExternalMonitor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalMonitor overwrites any union data inside the Setting as the provided ExternalMonitor
func (t *Setting) FromExternalMonitor(v ExternalMonitor) error {
	t.Type = "ExternalMonitor"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalMonitor performs a merge with any union data inside the Setting, using the provided ExternalMonitor
func (t *Setting) MergeExternalMonitor(v ExternalMonitor) error {
	t.Type = "ExternalMonitor"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQueryView returns the union data inside the Setting as a QueryView
func (t Setting) AsQueryView() (QueryView, error) {
	var body QueryView
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQueryView overwrites any union data inside the Setting as the provided QueryView
func (t *Setting) FromQueryView(v QueryView) error {
	t.Type = "QueryView"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQueryView performs a merge with any union data inside the Setting, using the provided QueryView
func (t *Setting) MergeQueryView(v QueryView) error {
	t.Type = "QueryView"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtelComponentMapping returns the union data inside the Setting as a OtelComponentMapping
func (t Setting) AsOtelComponentMapping() (OtelComponentMapping, error) {
	var body OtelComponentMapping
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtelComponentMapping overwrites any union data inside the Setting as the provided OtelComponentMapping
func (t *Setting) FromOtelComponentMapping(v OtelComponentMapping) error {
	t.Type = "OtelComponentMapping"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtelComponentMapping performs a merge with any union data inside the Setting, using the provided OtelComponentMapping
func (t *Setting) MergeOtelComponentMapping(v OtelComponentMapping) error {
	t.Type = "OtelComponentMapping"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtelRelationMapping returns the union data inside the Setting as a OtelRelationMapping
func (t Setting) AsOtelRelationMapping() (OtelRelationMapping, error) {
	var body OtelRelationMapping
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtelRelationMapping overwrites any union data inside the Setting as the provided OtelRelationMapping
func (t *Setting) FromOtelRelationMapping(v OtelRelationMapping) error {
	t.Type = "OtelRelationMapping"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtelRelationMapping performs a merge with any union data inside the Setting, using the provided OtelRelationMapping
func (t *Setting) MergeOtelRelationMapping(v OtelRelationMapping) error {
	t.Type = "OtelRelationMapping"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Setting) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Setting) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ExternalMonitor":
		return t.AsExternalMonitor()
	case "Monitor":
		return t.AsMonitor()
	case "NotificationChannel":
		return t.AsNotificationChannel()
	case "NotificationConfiguration":
		return t.AsNotificationConfiguration()
	case "OtelComponentMapping":
		return t.AsOtelComponentMapping()
	case "OtelRelationMapping":
		return t.AsOtelRelationMapping()
	case "QueryView":
		return t.AsQueryView()
	case "Sync":
		return t.AsSync()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Setting) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Setting) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsSettingsSnapshotStart returns the union data inside the SettingsProtocol as a SettingsSnapshotStart
func (t SettingsProtocol) AsSettingsSnapshotStart() (SettingsSnapshotStart, error) {
	var body SettingsSnapshotStart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSettingsSnapshotStart overwrites any union data inside the SettingsProtocol as the provided SettingsSnapshotStart
func (t *SettingsProtocol) FromSettingsSnapshotStart(v SettingsSnapshotStart) error {
	t.Type = "SettingsSnapshotStart"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSettingsSnapshotStart performs a merge with any union data inside the SettingsProtocol, using the provided SettingsSnapshotStart
func (t *SettingsProtocol) MergeSettingsSnapshotStart(v SettingsSnapshotStart) error {
	t.Type = "SettingsSnapshotStart"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSettingsSnapshotStop returns the union data inside the SettingsProtocol as a SettingsSnapshotStop
func (t SettingsProtocol) AsSettingsSnapshotStop() (SettingsSnapshotStop, error) {
	var body SettingsSnapshotStop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSettingsSnapshotStop overwrites any union data inside the SettingsProtocol as the provided SettingsSnapshotStop
func (t *SettingsProtocol) FromSettingsSnapshotStop(v SettingsSnapshotStop) error {
	t.Type = "SettingsSnapshotStop"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSettingsSnapshotStop performs a merge with any union data inside the SettingsProtocol, using the provided SettingsSnapshotStop
func (t *SettingsProtocol) MergeSettingsSnapshotStop(v SettingsSnapshotStop) error {
	t.Type = "SettingsSnapshotStop"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSettingsEnvelope returns the union data inside the SettingsProtocol as a SettingsEnvelope
func (t SettingsProtocol) AsSettingsEnvelope() (SettingsEnvelope, error) {
	var body SettingsEnvelope
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSettingsEnvelope overwrites any union data inside the SettingsProtocol as the provided SettingsEnvelope
func (t *SettingsProtocol) FromSettingsEnvelope(v SettingsEnvelope) error {
	t.Type = "SettingsEnvelope"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSettingsEnvelope performs a merge with any union data inside the SettingsProtocol, using the provided SettingsEnvelope
func (t *SettingsProtocol) MergeSettingsEnvelope(v SettingsEnvelope) error {
	t.Type = "SettingsEnvelope"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SettingsProtocol) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SettingsProtocol) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "SettingsEnvelope":
		return t.AsSettingsEnvelope()
	case "SettingsSnapshotStart":
		return t.AsSettingsSnapshotStart()
	case "SettingsSnapshotStop":
		return t.AsSettingsSnapshotStop()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SettingsProtocol) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SettingsProtocol) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsSyncActionComponent returns the union data inside the SyncAction as a SyncActionComponent
func (t SyncAction) AsSyncActionComponent() (SyncActionComponent, error) {
	var body SyncActionComponent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionComponent overwrites any union data inside the SyncAction as the provided SyncActionComponent
func (t *SyncAction) FromSyncActionComponent(v SyncActionComponent) error {
	t.ActionType = "SyncActionComponent"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionComponent performs a merge with any union data inside the SyncAction, using the provided SyncActionComponent
func (t *SyncAction) MergeSyncActionComponent(v SyncActionComponent) error {
	t.ActionType = "SyncActionComponent"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSyncActionRelation returns the union data inside the SyncAction as a SyncActionRelation
func (t SyncAction) AsSyncActionRelation() (SyncActionRelation, error) {
	var body SyncActionRelation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionRelation overwrites any union data inside the SyncAction as the provided SyncActionRelation
func (t *SyncAction) FromSyncActionRelation(v SyncActionRelation) error {
	t.ActionType = "SyncActionRelation"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionRelation performs a merge with any union data inside the SyncAction, using the provided SyncActionRelation
func (t *SyncAction) MergeSyncActionRelation(v SyncActionRelation) error {
	t.ActionType = "SyncActionRelation"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSyncActionCreate returns the union data inside the SyncAction as a SyncActionCreate
func (t SyncAction) AsSyncActionCreate() (SyncActionCreate, error) {
	var body SyncActionCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionCreate overwrites any union data inside the SyncAction as the provided SyncActionCreate
func (t *SyncAction) FromSyncActionCreate(v SyncActionCreate) error {
	t.ActionType = "SyncActionCreate"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionCreate performs a merge with any union data inside the SyncAction, using the provided SyncActionCreate
func (t *SyncAction) MergeSyncActionCreate(v SyncActionCreate) error {
	t.ActionType = "SyncActionCreate"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSyncActionCreateOnMerge returns the union data inside the SyncAction as a SyncActionCreateOnMerge
func (t SyncAction) AsSyncActionCreateOnMerge() (SyncActionCreateOnMerge, error) {
	var body SyncActionCreateOnMerge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionCreateOnMerge overwrites any union data inside the SyncAction as the provided SyncActionCreateOnMerge
func (t *SyncAction) FromSyncActionCreateOnMerge(v SyncActionCreateOnMerge) error {
	t.ActionType = "SyncActionCreateOnMerge"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionCreateOnMerge performs a merge with any union data inside the SyncAction, using the provided SyncActionCreateOnMerge
func (t *SyncAction) MergeSyncActionCreateOnMerge(v SyncActionCreateOnMerge) error {
	t.ActionType = "SyncActionCreateOnMerge"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SyncAction) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"actionType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SyncAction) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "SyncActionComponent":
		return t.AsSyncActionComponent()
	case "SyncActionCreate":
		return t.AsSyncActionCreate()
	case "SyncActionCreateOnMerge":
		return t.AsSyncActionCreateOnMerge()
	case "SyncActionRelation":
		return t.AsSyncActionRelation()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SyncAction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["actionType"], err = json.Marshal(t.ActionType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'actionType': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SyncAction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["actionType"]; found {
		err = json.Unmarshal(raw, &t.ActionType)
		if err != nil {
			return fmt.Errorf("error reading 'actionType': %w", err)
		}
	}

	return err
}

// AsSyncActionCreateComponent returns the union data inside the SyncActionComponent as a SyncActionCreateComponent
func (t SyncActionComponent) AsSyncActionCreateComponent() (SyncActionCreateComponent, error) {
	var body SyncActionCreateComponent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionCreateComponent overwrites any union data inside the SyncActionComponent as the provided SyncActionCreateComponent
func (t *SyncActionComponent) FromSyncActionCreateComponent(v SyncActionCreateComponent) error {
	v.ActionType = "SyncActionCreateComponent"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionCreateComponent performs a merge with any union data inside the SyncActionComponent, using the provided SyncActionCreateComponent
func (t *SyncActionComponent) MergeSyncActionCreateComponent(v SyncActionCreateComponent) error {
	v.ActionType = "SyncActionCreateComponent"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSyncActionCreateOnMerge returns the union data inside the SyncActionComponent as a SyncActionCreateOnMerge
func (t SyncActionComponent) AsSyncActionCreateOnMerge() (SyncActionCreateOnMerge, error) {
	var body SyncActionCreateOnMerge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionCreateOnMerge overwrites any union data inside the SyncActionComponent as the provided SyncActionCreateOnMerge
func (t *SyncActionComponent) FromSyncActionCreateOnMerge(v SyncActionCreateOnMerge) error {
	v.ActionType = "SyncActionCreateOnMerge"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionCreateOnMerge performs a merge with any union data inside the SyncActionComponent, using the provided SyncActionCreateOnMerge
func (t *SyncActionComponent) MergeSyncActionCreateOnMerge(v SyncActionCreateOnMerge) error {
	v.ActionType = "SyncActionCreateOnMerge"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SyncActionComponent) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"actionType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SyncActionComponent) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "SyncActionCreateComponent":
		return t.AsSyncActionCreateComponent()
	case "SyncActionCreateOnMerge":
		return t.AsSyncActionCreateOnMerge()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SyncActionComponent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SyncActionComponent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSyncActionCreateComponent returns the union data inside the SyncActionCreate as a SyncActionCreateComponent
func (t SyncActionCreate) AsSyncActionCreateComponent() (SyncActionCreateComponent, error) {
	var body SyncActionCreateComponent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionCreateComponent overwrites any union data inside the SyncActionCreate as the provided SyncActionCreateComponent
func (t *SyncActionCreate) FromSyncActionCreateComponent(v SyncActionCreateComponent) error {
	v.ActionType = "SyncActionCreateComponent"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionCreateComponent performs a merge with any union data inside the SyncActionCreate, using the provided SyncActionCreateComponent
func (t *SyncActionCreate) MergeSyncActionCreateComponent(v SyncActionCreateComponent) error {
	v.ActionType = "SyncActionCreateComponent"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSyncActionCreateRelation returns the union data inside the SyncActionCreate as a SyncActionCreateRelation
func (t SyncActionCreate) AsSyncActionCreateRelation() (SyncActionCreateRelation, error) {
	var body SyncActionCreateRelation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionCreateRelation overwrites any union data inside the SyncActionCreate as the provided SyncActionCreateRelation
func (t *SyncActionCreate) FromSyncActionCreateRelation(v SyncActionCreateRelation) error {
	v.ActionType = "SyncActionCreateRelation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionCreateRelation performs a merge with any union data inside the SyncActionCreate, using the provided SyncActionCreateRelation
func (t *SyncActionCreate) MergeSyncActionCreateRelation(v SyncActionCreateRelation) error {
	v.ActionType = "SyncActionCreateRelation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SyncActionCreate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"actionType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SyncActionCreate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "SyncActionCreateComponent":
		return t.AsSyncActionCreateComponent()
	case "SyncActionCreateRelation":
		return t.AsSyncActionCreateRelation()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SyncActionCreate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SyncActionCreate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSyncActionCreateRelation returns the union data inside the SyncActionRelation as a SyncActionCreateRelation
func (t SyncActionRelation) AsSyncActionCreateRelation() (SyncActionCreateRelation, error) {
	var body SyncActionCreateRelation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionCreateRelation overwrites any union data inside the SyncActionRelation as the provided SyncActionCreateRelation
func (t *SyncActionRelation) FromSyncActionCreateRelation(v SyncActionCreateRelation) error {
	v.ActionType = "SyncActionCreateRelation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionCreateRelation performs a merge with any union data inside the SyncActionRelation, using the provided SyncActionCreateRelation
func (t *SyncActionRelation) MergeSyncActionCreateRelation(v SyncActionCreateRelation) error {
	v.ActionType = "SyncActionCreateRelation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSyncActionCreateOnMerge returns the union data inside the SyncActionRelation as a SyncActionCreateOnMerge
func (t SyncActionRelation) AsSyncActionCreateOnMerge() (SyncActionCreateOnMerge, error) {
	var body SyncActionCreateOnMerge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyncActionCreateOnMerge overwrites any union data inside the SyncActionRelation as the provided SyncActionCreateOnMerge
func (t *SyncActionRelation) FromSyncActionCreateOnMerge(v SyncActionCreateOnMerge) error {
	v.ActionType = "SyncActionCreateOnMerge"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyncActionCreateOnMerge performs a merge with any union data inside the SyncActionRelation, using the provided SyncActionCreateOnMerge
func (t *SyncActionRelation) MergeSyncActionCreateOnMerge(v SyncActionCreateOnMerge) error {
	v.ActionType = "SyncActionCreateOnMerge"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SyncActionRelation) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"actionType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SyncActionRelation) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "SyncActionCreateOnMerge":
		return t.AsSyncActionCreateOnMerge()
	case "SyncActionCreateRelation":
		return t.AsSyncActionCreateRelation()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SyncActionRelation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SyncActionRelation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
