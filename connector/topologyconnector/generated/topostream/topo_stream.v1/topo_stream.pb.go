// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v3.21.12
// source: topo_stream.proto

package topo_stream_v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	structpb "google.golang.org/protobuf/types/known/structpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TopologyStreamComponent struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	ExternalId string                 `protobuf:"bytes,1,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
	// Identifiers for Sync service merging with other sync sources. Example aws node merges with k8s node
	Identifiers []string `protobuf:"bytes,2,rep,name=identifiers,proto3" json:"identifiers,omitempty"`
	Name        string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Component type. Is what help us match it with config and come with the rendering for overview, highlight pages
	TypeName         string  `protobuf:"bytes,4,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	TypeIdentifier   *string `protobuf:"bytes,5,opt,name=type_identifier,json=typeIdentifier,proto3,oneof" json:"type_identifier,omitempty"`
	LayerName        string  `protobuf:"bytes,6,opt,name=layer_name,json=layerName,proto3" json:"layer_name,omitempty"`
	LayerIdentifier  *string `protobuf:"bytes,7,opt,name=layer_identifier,json=layerIdentifier,proto3,oneof" json:"layer_identifier,omitempty"`
	DomainName       string  `protobuf:"bytes,8,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
	DomainIdentifier *string `protobuf:"bytes,9,opt,name=domain_identifier,json=domainIdentifier,proto3,oneof" json:"domain_identifier,omitempty"`
	// Resource Definition. Configuration or Specification that yielded the component instance.
	// We have a `Show Configuration` button on the "Highlight pages" that gives you access to this info.
	ResourceDefinition *structpb.Struct `protobuf:"bytes,10,opt,name=resource_definition,json=resourceDefinition,proto3" json:"resource_definition,omitempty"`
	// StatusData.
	// Contains the current status of a running component. Summary of a component lifecycle.
	// We have a `Show Status` button on the "Highlight pages" that gives you access to this info.
	StatusData    *structpb.Struct `protobuf:"bytes,11,opt,name=status_data,json=statusData,proto3" json:"status_data,omitempty"`
	Tags          []string         `protobuf:"bytes,12,rep,name=tags,proto3" json:"tags,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopologyStreamComponent) Reset() {
	*x = TopologyStreamComponent{}
	mi := &file_topo_stream_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopologyStreamComponent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopologyStreamComponent) ProtoMessage() {}

func (x *TopologyStreamComponent) ProtoReflect() protoreflect.Message {
	mi := &file_topo_stream_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopologyStreamComponent.ProtoReflect.Descriptor instead.
func (*TopologyStreamComponent) Descriptor() ([]byte, []int) {
	return file_topo_stream_proto_rawDescGZIP(), []int{0}
}

func (x *TopologyStreamComponent) GetExternalId() string {
	if x != nil {
		return x.ExternalId
	}
	return ""
}

func (x *TopologyStreamComponent) GetIdentifiers() []string {
	if x != nil {
		return x.Identifiers
	}
	return nil
}

func (x *TopologyStreamComponent) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TopologyStreamComponent) GetTypeName() string {
	if x != nil {
		return x.TypeName
	}
	return ""
}

func (x *TopologyStreamComponent) GetTypeIdentifier() string {
	if x != nil && x.TypeIdentifier != nil {
		return *x.TypeIdentifier
	}
	return ""
}

func (x *TopologyStreamComponent) GetLayerName() string {
	if x != nil {
		return x.LayerName
	}
	return ""
}

func (x *TopologyStreamComponent) GetLayerIdentifier() string {
	if x != nil && x.LayerIdentifier != nil {
		return *x.LayerIdentifier
	}
	return ""
}

func (x *TopologyStreamComponent) GetDomainName() string {
	if x != nil {
		return x.DomainName
	}
	return ""
}

func (x *TopologyStreamComponent) GetDomainIdentifier() string {
	if x != nil && x.DomainIdentifier != nil {
		return *x.DomainIdentifier
	}
	return ""
}

func (x *TopologyStreamComponent) GetResourceDefinition() *structpb.Struct {
	if x != nil {
		return x.ResourceDefinition
	}
	return nil
}

func (x *TopologyStreamComponent) GetStatusData() *structpb.Struct {
	if x != nil {
		return x.StatusData
	}
	return nil
}

func (x *TopologyStreamComponent) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

// No direction for the relation requires. We set it as ONE_WAY as source -> target
type TopologyStreamRelation struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	ExternalId string                 `protobuf:"bytes,1,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
	// Works with datasource unique Identifiers, it allow us to not have to send dummy components, the components need to exist on some datasource:shardId OtelComponentMapping stream
	// which might not necessarily be the same nor the same partition where this message lands. Thus components and relations are not in the same datasource:shard state.
	// Will need some changes on how to propagate this relations to the sync service. Potentially a new definition of ExtopoComponentId that helps the grouper make the late binding of
	// source/target. And the detection and error/warning raising of incomplete relations will be delayed to the grouper.
	// Global unique identifier of a source component.
	SourceIdentifier string `protobuf:"bytes,2,opt,name=source_identifier,json=sourceIdentifier,proto3" json:"source_identifier,omitempty"` // E.g. datasource:externalId ...
	// Global unique identifier of a target component.
	TargetIdentifier string `protobuf:"bytes,3,opt,name=target_identifier,json=targetIdentifier,proto3" json:"target_identifier,omitempty"` // E.g. datasource:externalId ...
	Name             string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Relation type name
	TypeName       string   `protobuf:"bytes,5,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	TypeIdentifier *string  `protobuf:"bytes,6,opt,name=type_identifier,json=typeIdentifier,proto3,oneof" json:"type_identifier,omitempty"`
	Tags           []string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TopologyStreamRelation) Reset() {
	*x = TopologyStreamRelation{}
	mi := &file_topo_stream_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopologyStreamRelation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopologyStreamRelation) ProtoMessage() {}

func (x *TopologyStreamRelation) ProtoReflect() protoreflect.Message {
	mi := &file_topo_stream_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopologyStreamRelation.ProtoReflect.Descriptor instead.
func (*TopologyStreamRelation) Descriptor() ([]byte, []int) {
	return file_topo_stream_proto_rawDescGZIP(), []int{1}
}

func (x *TopologyStreamRelation) GetExternalId() string {
	if x != nil {
		return x.ExternalId
	}
	return ""
}

func (x *TopologyStreamRelation) GetSourceIdentifier() string {
	if x != nil {
		return x.SourceIdentifier
	}
	return ""
}

func (x *TopologyStreamRelation) GetTargetIdentifier() string {
	if x != nil {
		return x.TargetIdentifier
	}
	return ""
}

func (x *TopologyStreamRelation) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TopologyStreamRelation) GetTypeName() string {
	if x != nil {
		return x.TypeName
	}
	return ""
}

func (x *TopologyStreamRelation) GetTypeIdentifier() string {
	if x != nil && x.TypeIdentifier != nil {
		return *x.TypeIdentifier
	}
	return ""
}

func (x *TopologyStreamRelation) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

// *
// Delete message for any datasource:shardId
type TopologyStreamRemove struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Do we need to track the cause of removal? Is it always the OtelMapping settings being deleted?
	RemovalCause  string `protobuf:"bytes,1,opt,name=removal_cause,json=removalCause,proto3" json:"removal_cause,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopologyStreamRemove) Reset() {
	*x = TopologyStreamRemove{}
	mi := &file_topo_stream_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopologyStreamRemove) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopologyStreamRemove) ProtoMessage() {}

func (x *TopologyStreamRemove) ProtoReflect() protoreflect.Message {
	mi := &file_topo_stream_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopologyStreamRemove.ProtoReflect.Descriptor instead.
func (*TopologyStreamRemove) Descriptor() ([]byte, []int) {
	return file_topo_stream_proto_rawDescGZIP(), []int{2}
}

func (x *TopologyStreamRemove) GetRemovalCause() string {
	if x != nil {
		return x.RemovalCause
	}
	return ""
}

// *
// Allow us to potentially send resolutions for issueIds in the future. Makes the presentation and handling them in the Be easier.
type TopoStreamError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Category      string                 `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
	IssueId       string                 `protobuf:"bytes,2,opt,name=issue_id,json=issueId,proto3" json:"issue_id,omitempty"`
	Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopoStreamError) Reset() {
	*x = TopoStreamError{}
	mi := &file_topo_stream_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopoStreamError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopoStreamError) ProtoMessage() {}

func (x *TopoStreamError) ProtoReflect() protoreflect.Message {
	mi := &file_topo_stream_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopoStreamError.ProtoReflect.Descriptor instead.
func (*TopoStreamError) Descriptor() ([]byte, []int) {
	return file_topo_stream_proto_rawDescGZIP(), []int{3}
}

func (x *TopoStreamError) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *TopoStreamError) GetIssueId() string {
	if x != nil {
		return x.IssueId
	}
	return ""
}

func (x *TopoStreamError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// *
// Messages for REPEAT_SNAPSHOTS consistency model
type TopologyStreamSnapshotData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defines how often we expect a new snapshot. Helps raise warnings related to data being not up to date
	RepeatIntervalMs int32 `protobuf:"varint,1,opt,name=repeat_interval_ms,json=repeatIntervalMs,proto3" json:"repeat_interval_ms,omitempty"`
	// Defines the grace period to keep the data in the case that we datasource:shardId is decommissioned, we don't want
	// data hanging permanently
	ExpiryIntervalMs *int64                     `protobuf:"varint,2,opt,name=expiry_interval_ms,json=expiryIntervalMs,proto3,oneof" json:"expiry_interval_ms,omitempty"`
	SnapshotStart    *bool                      `protobuf:"varint,3,opt,name=snapshot_start,json=snapshotStart,proto3,oneof" json:"snapshot_start,omitempty"`
	SnapshotStop     *bool                      `protobuf:"varint,4,opt,name=snapshot_stop,json=snapshotStop,proto3,oneof" json:"snapshot_stop,omitempty"`
	Components       []*TopologyStreamComponent `protobuf:"bytes,5,rep,name=components,proto3" json:"components,omitempty"`
	Relations        []*TopologyStreamRelation  `protobuf:"bytes,6,rep,name=relations,proto3" json:"relations,omitempty"`
	// In case the Mapping fails and the Otel collector would like to push some messages that we can display when the user requests the TopologyStream status via the cli
	Errors        []*TopoStreamError `protobuf:"bytes,7,rep,name=errors,proto3" json:"errors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopologyStreamSnapshotData) Reset() {
	*x = TopologyStreamSnapshotData{}
	mi := &file_topo_stream_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopologyStreamSnapshotData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopologyStreamSnapshotData) ProtoMessage() {}

func (x *TopologyStreamSnapshotData) ProtoReflect() protoreflect.Message {
	mi := &file_topo_stream_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopologyStreamSnapshotData.ProtoReflect.Descriptor instead.
func (*TopologyStreamSnapshotData) Descriptor() ([]byte, []int) {
	return file_topo_stream_proto_rawDescGZIP(), []int{4}
}

func (x *TopologyStreamSnapshotData) GetRepeatIntervalMs() int32 {
	if x != nil {
		return x.RepeatIntervalMs
	}
	return 0
}

func (x *TopologyStreamSnapshotData) GetExpiryIntervalMs() int64 {
	if x != nil && x.ExpiryIntervalMs != nil {
		return *x.ExpiryIntervalMs
	}
	return 0
}

func (x *TopologyStreamSnapshotData) GetSnapshotStart() bool {
	if x != nil && x.SnapshotStart != nil {
		return *x.SnapshotStart
	}
	return false
}

func (x *TopologyStreamSnapshotData) GetSnapshotStop() bool {
	if x != nil && x.SnapshotStop != nil {
		return *x.SnapshotStop
	}
	return false
}

func (x *TopologyStreamSnapshotData) GetComponents() []*TopologyStreamComponent {
	if x != nil {
		return x.Components
	}
	return nil
}

func (x *TopologyStreamSnapshotData) GetRelations() []*TopologyStreamRelation {
	if x != nil {
		return x.Relations
	}
	return nil
}

func (x *TopologyStreamSnapshotData) GetErrors() []*TopoStreamError {
	if x != nil {
		return x.Errors
	}
	return nil
}

// *
// Messages for REPEAT_ELEMENTS consistency model
type TopologyStreamRepeatElementsData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defines the grace period to keep the data in the case that we datasource:shardId is decommissioned, we don't want
	// data hanging permanently
	ExpiryIntervalMs int64                      `protobuf:"varint,1,opt,name=expiry_interval_ms,json=expiryIntervalMs,proto3" json:"expiry_interval_ms,omitempty"`
	Components       []*TopologyStreamComponent `protobuf:"bytes,2,rep,name=components,proto3" json:"components,omitempty"`
	Relations        []*TopologyStreamRelation  `protobuf:"bytes,3,rep,name=relations,proto3" json:"relations,omitempty"`
	// In case the Mapping fails and the Otel collector would like to push some messages that we can display when the user requests the TopologyStream status via the cli
	Errors        []*TopoStreamError `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopologyStreamRepeatElementsData) Reset() {
	*x = TopologyStreamRepeatElementsData{}
	mi := &file_topo_stream_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopologyStreamRepeatElementsData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopologyStreamRepeatElementsData) ProtoMessage() {}

func (x *TopologyStreamRepeatElementsData) ProtoReflect() protoreflect.Message {
	mi := &file_topo_stream_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopologyStreamRepeatElementsData.ProtoReflect.Descriptor instead.
func (*TopologyStreamRepeatElementsData) Descriptor() ([]byte, []int) {
	return file_topo_stream_proto_rawDescGZIP(), []int{5}
}

func (x *TopologyStreamRepeatElementsData) GetExpiryIntervalMs() int64 {
	if x != nil {
		return x.ExpiryIntervalMs
	}
	return 0
}

func (x *TopologyStreamRepeatElementsData) GetComponents() []*TopologyStreamComponent {
	if x != nil {
		return x.Components
	}
	return nil
}

func (x *TopologyStreamRepeatElementsData) GetRelations() []*TopologyStreamRelation {
	if x != nil {
		return x.Relations
	}
	return nil
}

func (x *TopologyStreamRepeatElementsData) GetErrors() []*TopoStreamError {
	if x != nil {
		return x.Errors
	}
	return nil
}

// *
// == Possible Messages
//
// Based on the design where we have several Otel collectors deployed and ack that OtelComponentMapping and the OtelRelationMapping
// will be colocated in different collectors drives the protocol into having message keys carrying encoded the
// so we get the property that all messages for a datasource:shardId land in the same partition and we get them in order.. Order among the whole dataSource is not
// needed as the SyncService is tolerant to for example keeping in hold relations in the meantime that the components are observed.
//
//datasource:shardId (stream:subStreamId)
type TopologyStreamMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Timestamp when the agent collected the data, Helpful to calculate pipeline latencies
	CollectionTimestamp int64 `protobuf:"varint,1,opt,name=collection_timestamp,json=collectionTimestamp,proto3" json:"collection_timestamp,omitempty"`
	// Timestamp when the record was submitted for processing on the platform. Helpful to calculate pipeline latencies
	SubmittedTimestamp int64 `protobuf:"varint,2,opt,name=submitted_timestamp,json=submittedTimestamp,proto3" json:"submitted_timestamp,omitempty"`
	// Types that are valid to be assigned to Payload:
	//
	//	*TopologyStreamMessage_TopologyStreamSnapshotData
	//	*TopologyStreamMessage_TopologyStreamRepeatElementsData
	//	*TopologyStreamMessage_TopologyStreamRemove
	Payload       isTopologyStreamMessage_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopologyStreamMessage) Reset() {
	*x = TopologyStreamMessage{}
	mi := &file_topo_stream_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopologyStreamMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopologyStreamMessage) ProtoMessage() {}

func (x *TopologyStreamMessage) ProtoReflect() protoreflect.Message {
	mi := &file_topo_stream_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopologyStreamMessage.ProtoReflect.Descriptor instead.
func (*TopologyStreamMessage) Descriptor() ([]byte, []int) {
	return file_topo_stream_proto_rawDescGZIP(), []int{6}
}

func (x *TopologyStreamMessage) GetCollectionTimestamp() int64 {
	if x != nil {
		return x.CollectionTimestamp
	}
	return 0
}

func (x *TopologyStreamMessage) GetSubmittedTimestamp() int64 {
	if x != nil {
		return x.SubmittedTimestamp
	}
	return 0
}

func (x *TopologyStreamMessage) GetPayload() isTopologyStreamMessage_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *TopologyStreamMessage) GetTopologyStreamSnapshotData() *TopologyStreamSnapshotData {
	if x != nil {
		if x, ok := x.Payload.(*TopologyStreamMessage_TopologyStreamSnapshotData); ok {
			return x.TopologyStreamSnapshotData
		}
	}
	return nil
}

func (x *TopologyStreamMessage) GetTopologyStreamRepeatElementsData() *TopologyStreamRepeatElementsData {
	if x != nil {
		if x, ok := x.Payload.(*TopologyStreamMessage_TopologyStreamRepeatElementsData); ok {
			return x.TopologyStreamRepeatElementsData
		}
	}
	return nil
}

func (x *TopologyStreamMessage) GetTopologyStreamRemove() *TopologyStreamRemove {
	if x != nil {
		if x, ok := x.Payload.(*TopologyStreamMessage_TopologyStreamRemove); ok {
			return x.TopologyStreamRemove
		}
	}
	return nil
}

type isTopologyStreamMessage_Payload interface {
	isTopologyStreamMessage_Payload()
}

type TopologyStreamMessage_TopologyStreamSnapshotData struct {
	TopologyStreamSnapshotData *TopologyStreamSnapshotData `protobuf:"bytes,3,opt,name=topology_stream_snapshot_data,json=topologyStreamSnapshotData,proto3,oneof"`
}

type TopologyStreamMessage_TopologyStreamRepeatElementsData struct {
	TopologyStreamRepeatElementsData *TopologyStreamRepeatElementsData `protobuf:"bytes,4,opt,name=topology_stream_repeat_elements_data,json=topologyStreamRepeatElementsData,proto3,oneof"`
}

type TopologyStreamMessage_TopologyStreamRemove struct {
	TopologyStreamRemove *TopologyStreamRemove `protobuf:"bytes,5,opt,name=topology_stream_remove,json=topologyStreamRemove,proto3,oneof"`
}

func (*TopologyStreamMessage_TopologyStreamSnapshotData) isTopologyStreamMessage_Payload() {}

func (*TopologyStreamMessage_TopologyStreamRepeatElementsData) isTopologyStreamMessage_Payload() {}

func (*TopologyStreamMessage_TopologyStreamRemove) isTopologyStreamMessage_Payload() {}

var File_topo_stream_proto protoreflect.FileDescriptor

const file_topo_stream_proto_rawDesc = "" +
	"\n" +
	"\x11topo_stream.proto\x12\x0etopo_stream.v1\x1a\x1cgoogle/protobuf/struct.proto\"\xb4\x04\n" +
	"\x17TopologyStreamComponent\x12\x1f\n" +
	"\vexternal_id\x18\x01 \x01(\tR\n" +
	"externalId\x12 \n" +
	"\videntifiers\x18\x02 \x03(\tR\videntifiers\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x1b\n" +
	"\ttype_name\x18\x04 \x01(\tR\btypeName\x12,\n" +
	"\x0ftype_identifier\x18\x05 \x01(\tH\x00R\x0etypeIdentifier\x88\x01\x01\x12\x1d\n" +
	"\n" +
	"layer_name\x18\x06 \x01(\tR\tlayerName\x12.\n" +
	"\x10layer_identifier\x18\a \x01(\tH\x01R\x0flayerIdentifier\x88\x01\x01\x12\x1f\n" +
	"\vdomain_name\x18\b \x01(\tR\n" +
	"domainName\x120\n" +
	"\x11domain_identifier\x18\t \x01(\tH\x02R\x10domainIdentifier\x88\x01\x01\x12H\n" +
	"\x13resource_definition\x18\n" +
	" \x01(\v2\x17.google.protobuf.StructR\x12resourceDefinition\x128\n" +
	"\vstatus_data\x18\v \x01(\v2\x17.google.protobuf.StructR\n" +
	"statusData\x12\x12\n" +
	"\x04tags\x18\f \x03(\tR\x04tagsB\x12\n" +
	"\x10_type_identifierB\x13\n" +
	"\x11_layer_identifierB\x14\n" +
	"\x12_domain_identifier\"\x9a\x02\n" +
	"\x16TopologyStreamRelation\x12\x1f\n" +
	"\vexternal_id\x18\x01 \x01(\tR\n" +
	"externalId\x12+\n" +
	"\x11source_identifier\x18\x02 \x01(\tR\x10sourceIdentifier\x12+\n" +
	"\x11target_identifier\x18\x03 \x01(\tR\x10targetIdentifier\x12\x12\n" +
	"\x04name\x18\x04 \x01(\tR\x04name\x12\x1b\n" +
	"\ttype_name\x18\x05 \x01(\tR\btypeName\x12,\n" +
	"\x0ftype_identifier\x18\x06 \x01(\tH\x00R\x0etypeIdentifier\x88\x01\x01\x12\x12\n" +
	"\x04tags\x18\a \x03(\tR\x04tagsB\x12\n" +
	"\x10_type_identifier\";\n" +
	"\x14TopologyStreamRemove\x12#\n" +
	"\rremoval_cause\x18\x01 \x01(\tR\fremovalCause\"b\n" +
	"\x0fTopoStreamError\x12\x1a\n" +
	"\bcategory\x18\x01 \x01(\tR\bcategory\x12\x19\n" +
	"\bissue_id\x18\x02 \x01(\tR\aissueId\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"\xd7\x03\n" +
	"\x1aTopologyStreamSnapshotData\x12,\n" +
	"\x12repeat_interval_ms\x18\x01 \x01(\x05R\x10repeatIntervalMs\x121\n" +
	"\x12expiry_interval_ms\x18\x02 \x01(\x03H\x00R\x10expiryIntervalMs\x88\x01\x01\x12*\n" +
	"\x0esnapshot_start\x18\x03 \x01(\bH\x01R\rsnapshotStart\x88\x01\x01\x12(\n" +
	"\rsnapshot_stop\x18\x04 \x01(\bH\x02R\fsnapshotStop\x88\x01\x01\x12G\n" +
	"\n" +
	"components\x18\x05 \x03(\v2'.topo_stream.v1.TopologyStreamComponentR\n" +
	"components\x12D\n" +
	"\trelations\x18\x06 \x03(\v2&.topo_stream.v1.TopologyStreamRelationR\trelations\x127\n" +
	"\x06errors\x18\a \x03(\v2\x1f.topo_stream.v1.TopoStreamErrorR\x06errorsB\x15\n" +
	"\x13_expiry_interval_msB\x11\n" +
	"\x0f_snapshot_startB\x10\n" +
	"\x0e_snapshot_stop\"\x98\x02\n" +
	" TopologyStreamRepeatElementsData\x12,\n" +
	"\x12expiry_interval_ms\x18\x01 \x01(\x03R\x10expiryIntervalMs\x12G\n" +
	"\n" +
	"components\x18\x02 \x03(\v2'.topo_stream.v1.TopologyStreamComponentR\n" +
	"components\x12D\n" +
	"\trelations\x18\x03 \x03(\v2&.topo_stream.v1.TopologyStreamRelationR\trelations\x127\n" +
	"\x06errors\x18\x04 \x03(\v2\x1f.topo_stream.v1.TopoStreamErrorR\x06errors\"\xda\x03\n" +
	"\x15TopologyStreamMessage\x121\n" +
	"\x14collection_timestamp\x18\x01 \x01(\x03R\x13collectionTimestamp\x12/\n" +
	"\x13submitted_timestamp\x18\x02 \x01(\x03R\x12submittedTimestamp\x12o\n" +
	"\x1dtopology_stream_snapshot_data\x18\x03 \x01(\v2*.topo_stream.v1.TopologyStreamSnapshotDataH\x00R\x1atopologyStreamSnapshotData\x12\x82\x01\n" +
	"$topology_stream_repeat_elements_data\x18\x04 \x01(\v20.topo_stream.v1.TopologyStreamRepeatElementsDataH\x00R topologyStreamRepeatElementsData\x12\\\n" +
	"\x16topology_stream_remove\x18\x05 \x01(\v2$.topo_stream.v1.TopologyStreamRemoveH\x00R\x14topologyStreamRemoveB\t\n" +
	"\apayloadB4\n" +
	"\"com.stackstate.topoStream.protocolZ\x0etopo_stream.v1b\x06proto3"

var (
	file_topo_stream_proto_rawDescOnce sync.Once
	file_topo_stream_proto_rawDescData []byte
)

func file_topo_stream_proto_rawDescGZIP() []byte {
	file_topo_stream_proto_rawDescOnce.Do(func() {
		file_topo_stream_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_topo_stream_proto_rawDesc), len(file_topo_stream_proto_rawDesc)))
	})
	return file_topo_stream_proto_rawDescData
}

var file_topo_stream_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_topo_stream_proto_goTypes = []any{
	(*TopologyStreamComponent)(nil),          // 0: topo_stream.v1.TopologyStreamComponent
	(*TopologyStreamRelation)(nil),           // 1: topo_stream.v1.TopologyStreamRelation
	(*TopologyStreamRemove)(nil),             // 2: topo_stream.v1.TopologyStreamRemove
	(*TopoStreamError)(nil),                  // 3: topo_stream.v1.TopoStreamError
	(*TopologyStreamSnapshotData)(nil),       // 4: topo_stream.v1.TopologyStreamSnapshotData
	(*TopologyStreamRepeatElementsData)(nil), // 5: topo_stream.v1.TopologyStreamRepeatElementsData
	(*TopologyStreamMessage)(nil),            // 6: topo_stream.v1.TopologyStreamMessage
	(*structpb.Struct)(nil),                  // 7: google.protobuf.Struct
}
var file_topo_stream_proto_depIdxs = []int32{
	7,  // 0: topo_stream.v1.TopologyStreamComponent.resource_definition:type_name -> google.protobuf.Struct
	7,  // 1: topo_stream.v1.TopologyStreamComponent.status_data:type_name -> google.protobuf.Struct
	0,  // 2: topo_stream.v1.TopologyStreamSnapshotData.components:type_name -> topo_stream.v1.TopologyStreamComponent
	1,  // 3: topo_stream.v1.TopologyStreamSnapshotData.relations:type_name -> topo_stream.v1.TopologyStreamRelation
	3,  // 4: topo_stream.v1.TopologyStreamSnapshotData.errors:type_name -> topo_stream.v1.TopoStreamError
	0,  // 5: topo_stream.v1.TopologyStreamRepeatElementsData.components:type_name -> topo_stream.v1.TopologyStreamComponent
	1,  // 6: topo_stream.v1.TopologyStreamRepeatElementsData.relations:type_name -> topo_stream.v1.TopologyStreamRelation
	3,  // 7: topo_stream.v1.TopologyStreamRepeatElementsData.errors:type_name -> topo_stream.v1.TopoStreamError
	4,  // 8: topo_stream.v1.TopologyStreamMessage.topology_stream_snapshot_data:type_name -> topo_stream.v1.TopologyStreamSnapshotData
	5,  // 9: topo_stream.v1.TopologyStreamMessage.topology_stream_repeat_elements_data:type_name -> topo_stream.v1.TopologyStreamRepeatElementsData
	2,  // 10: topo_stream.v1.TopologyStreamMessage.topology_stream_remove:type_name -> topo_stream.v1.TopologyStreamRemove
	11, // [11:11] is the sub-list for method output_type
	11, // [11:11] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { file_topo_stream_proto_init() }
func file_topo_stream_proto_init() {
	if File_topo_stream_proto != nil {
		return
	}
	file_topo_stream_proto_msgTypes[0].OneofWrappers = []any{}
	file_topo_stream_proto_msgTypes[1].OneofWrappers = []any{}
	file_topo_stream_proto_msgTypes[4].OneofWrappers = []any{}
	file_topo_stream_proto_msgTypes[6].OneofWrappers = []any{
		(*TopologyStreamMessage_TopologyStreamSnapshotData)(nil),
		(*TopologyStreamMessage_TopologyStreamRepeatElementsData)(nil),
		(*TopologyStreamMessage_TopologyStreamRemove)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_topo_stream_proto_rawDesc), len(file_topo_stream_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_topo_stream_proto_goTypes,
		DependencyIndexes: file_topo_stream_proto_depIdxs,
		MessageInfos:      file_topo_stream_proto_msgTypes,
	}.Build()
	File_topo_stream_proto = out.File
	file_topo_stream_proto_goTypes = nil
	file_topo_stream_proto_depIdxs = nil
}
